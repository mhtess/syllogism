
(define all-true (lambda (lst) (apply and lst)))
(define some-true (lambda (lst) (apply or lst)))

(define all
  (lambda (A B)
    (all-true (map (lambda (x) (if (A x) (B x) true))	
                   objects))))

(define some
  (lambda (A B)
    (some-true (map (lambda (x) (if (A x) (B x) false)) 
                    objects))))

(define none
  (lambda (A B)
    (all-true (map (lambda (x) (if (A x) (not (B x)) true)) 
                   objects))))

(define notall
  (lambda (A B)
    (some-true (map (lambda (x) (if (A x) (not (B x)) false)) 
                    objects))))		
(define (meaning word)
  (case word
        (('all) all)
        (('some) some)
        (('notall) notall)
        (('none) none)))

(define (conclusion-prior) (uniform-draw (list 'all 'some 'notall 'none)))
(define (premise-prior) (uniform-draw (list 'all 'some 'notall 'none)))

(define br 0.90)
(define objects (list 'o1 'o2 'o3))

(define reasoner (mem (lambda (premise-one premise-two depth)
  (enumeration-query
   		(define A (mem (lambda (x) (flip br))))
		(define B (mem (lambda (x) (flip br))))
		(define C (mem (lambda (x) (flip br))))

		(define conclusion (conclusion-prior))
		
		conclusion
		
		(if (= depth 0)
			(and 
				((meaning conclusion) A C)
				((meaning premise-one) A B)
				((meaning premise-two) B C))
			(equal? (list premise-one premise-two) (apply multinomial (audience conclusion depth))))))))
			

(define audience (mem (lambda (conclusion depth)
	(enumeration-query 
		(define premise-one (premise-prior))
		(define premise-two (premise-prior))
		
		(list premise-one premise-two)
		
		(equal? conclusion (apply multinomial (reasoner premise-one premise-two (- depth 1))))))))
	