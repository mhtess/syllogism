// time webppl syllogism-test.wppl --require syllUtils

// var fpath = "/Users/mht/Documents/research/syllogism/models/ripsdata/"
// var ripsData = syllUtils.readCSV(fpath+"rips-data-raw.csv").data
// var ripsDF = dataFrame(ripsData)
// var syllogisms = _.uniq(_.pluck(ripsDF, "syllogism"))

// for testing purposes, keep n_objects fixed
// var objects = ["g1","g2","g3", "g4"]

// var baseRates = map(function(x){return x/20}, _.range(1, 20, 1))
var baseRates = [0.05,0.1,0.15,0.2,0.25,0.3,0.35,0.4,0.45,0.5,0.55,0.6,0.65]
var nObjects = [4,5,6,7,8,9,10]

var possiblePriors = allPriors(nObjects, baseRates)

var RSAoptions ={pragmaticInterpretation: true,
                 QUD_E1: "conclusion", // if pragmaticInterpretation==false, this must be conclusion
                 pragmaticProduction: false,
                 QUD_cL0: "state"}

var RSAparams = {
 speakerOptimality_E1: 2,
 speakerOptimality_cL0: 2,
 cost: 2
}

var priorParams = {
  baseRate: 0.4,
  n_objects: 10,
  empiricalPrior: [null]
}

var prior = possiblePriors[priorParams.n_objects][priorParams.baseRate]

var syllogism = 'EE1'
var syll = scholasticCodeToPremises(syllogism)


var predictionERP = syllogisticRSA(syll, 
									 RSAparams, 
									 RSAoptions,
									 prior)


// softmaxSpeaker(predictionERP,5)


var marginalizeConclusions = function(reasonerERP, conclusion){
Enumerate(function(){
  var c = sample(reasonerERP)
  return _.isArray(c[1]) ? 
  	conclusion[1]==c[0][1] || conclusion[1]==c[1][1] : 
  	conclusion[1]==c[1]
})
}

console.log("P(all) =" + Math.exp(marginalizeConclusions(predictionERP,[["C","A"], "all"]).score([], true)))
console.log("P(some) =" + Math.exp(marginalizeConclusions(predictionERP,[["C","A"], "some"]).score([], true)))
console.log("P(not all) = " + Math.exp(marginalizeConclusions(predictionERP,[["C","A"], "not all"]).score([], true)))
console.log("P(none) =" + Math.exp(marginalizeConclusions(predictionERP,[["C","A"], "none"]).score([], true)))


// prior.support([]).length