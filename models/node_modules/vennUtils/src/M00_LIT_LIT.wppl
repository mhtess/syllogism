var M00_LIT_LIT = function(){

  var speakerOptimality = {
		alpha_1 : -99,
    alpha_2 : uniformDrift({a: 0, b: 10, width: 2})
	}

  var noise = uniformDrift({a: 0, b: 0.1, width: 0.01})

  // var regionProbs = repeat(7, function(){ return uniformDrift({a: 0, b: 1, width: 0.1}) })
	var regionParams = {
		"A_C": uniformDrift({a: 0, b: 1, width: 0.1}),
		"AB_BC": uniformDrift({a: 0, b: 1, width: 0.1}),
		"ABC": uniformDrift({a: 0, b: 1, width: 0.1}),
		"AC": uniformDrift({a: 0, b: 1, width: 0.1}),
		"B": 0.1
	}
	// C, B, BC, A,  AC, AB, ABC
	var regionProbs = [
		regionParams.A_C,
		regionParams.B,
		regionParams.AB_BC,
		regionParams.A_C,
		regionParams.AC,
		regionParams.AB_BC,
		regionParams.ABC
	]
  // display(regionProbs)
  var firstTermPrefWeight  = uniformDrift({a: 1, b: 5, width: 0.5}) // 1 + exponential({a:1}) //uniformDrift({a: 1, b: 10, width: 1})
  // display(firstTermPrefWeight)
  var nvcWeight = 1//uniformDrift({a: 0, b: 2, width: 0.25}) //exponential({a: 1})
  // display(nvcWeight)

  // var full_venn_space = Enumerate(function() {
	var VennPrior = makeVennPrior(regionProbs)

  var venn_interpreter = cache(function(sentences) {
    Infer({
      model: function() {
        var venn = sample(VennPrior)
        foreach(sentences, function(utterance) {
          var meaningFn = lexicon[utterance.quantifier]
          condition(
            flip(noise) ? true :
            meaningFn(venn, utterance.p1, utterance.p2)
          )
        })
        return venn
      },
      method: "enumerate"
    })
  }, 10000)

  var conclusion_model = function(premises){
    // display('before listener')
		var first_term_preference = firstTermPreference(premises) // A, C, or false
		var prms = {nvcWeight, firstTermPrefWeight}
		// display(first_term_preference)
		// display(prms)
		var ConclusionPrior = makeConclusionPrior(first_term_preference, prms)

    var PremiseInterpretation = venn_interpreter(premises)
    // display(JSON.stringify(PremiseInterpretation))

    // display('end listener')

    var conclusionDist = Infer({model: function(){
      var venn = sample(PremiseInterpretation)
      // display(JSON.stringify(venn))
      var conclusion = sample(ConclusionPrior)
      var conclusionMeaningFn = lexicon[conclusion.quantifier]
      condition(conclusionMeaningFn(venn, conclusion.p1, conclusion.p2))
      return formatSentence(conclusion)
    }})

    return exponentiateRenormalize(conclusionDist, speakerOptimality.alpha_2)

  }


		foreach(premise_1s, function(prem_1){
				foreach(premise_2s, function(prem_2){
					// display(formatSentence(prem_1) + " _ " + formatSentence(prem_2))
					var data_filtered = _.filter(df_clean, {prem_1, prem_2})
					// display(data_filtered)
					var syllogisticPremises = [prem_1, prem_2]
					// display(syllogisticPremises)
					// display('before rsa')
					// display(pragmatics)
					// display(JSON.stringify(syllogisticPremises))
					var rsaPredictions = conclusion_model(syllogisticPremises)
					// display('after rsa')
					// var rsaNoise = addNoise(rsaPredictions, noise)
					// display(JSON.stringify(rsaNoise))

					mapData({data: _.map(data_filtered, "conclusion")}, function(d){
						var scr = rsaPredictions.score(d)
						// display(scr)
						scr == -Infinity ? display(formatSentence(prem_1) + " _ " + formatSentence(prem_2) + " _ " + d) : null

						observe(rsaPredictions, d)
					})

					foreach(rsaPredictions.support(), function(s){

						query.add(
							["prediction", formatSentence(prem_1), formatSentence(prem_2), s],
							Math.exp(rsaPredictions.score(s))
						)
					})
				})
		})

		query.add(["parameter", "speakerOptimality", "alpha_2", -99], speakerOptimality.alpha_2)
		query.add(["parameter", "noise", -99, -99], noise)
		query.add(["parameter", "firstTermPreference", -99, -99], firstTermPrefWeight)
		query.add(["parameter", "nvcWeight", -99, -99], nvcWeight)

		var xkh = map2(function(region, priorProb) {
			var regionLabel = parseVennDiagram(region)
			query.add(["parameter", "statePrior", regionLabel, -99], priorProb)
		}, regions, regionProbs)

		return query

}
