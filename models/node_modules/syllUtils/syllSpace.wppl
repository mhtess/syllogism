// creating the syllogistic space

// ordering of the 8-state properties
var propertyTuples = [[0,0,0],[0,0,1],[0,1,0],[0,1,1],
                      [1,0,0],[1,0,1],[1,1,0],[1,1,1]]


var quantifiers = ["all","some","none", "not all"];
var sentenceForms = [ ["A","B"],["B","A"],
                      ["B","C"],["C","B"],
                      ["A","C"],["C","A"]];

var propertyOrder = ["A","B","C"];


var conclusionOrder = [ [["C","A"],"all"],
                        [["C","A"],"none"],
                        [["C","A"],"some"],
                        [["C","A"],"not all"]];

var conclusionListOrder = [ [["C","A"],"all"],
                          [["C","A"],"none"],
                          [["C","A"],"some"],
                          [["C","A"],"not all"],
                          [[["C","A"],"all"],[["C","A"],"some"]],
                          [[["C","A"],"some"],[["C","A"],"not all"]],
                          [[["C","A"],"none"],[["C","A"],"not all"]]];


var binarizedConclusionSet = ['1000',
                              '0100',
                              '0010',
                              '0001',
                              '1010',
                              '0011',
                              '0101'];


var syllogisticSentences = _.flatten(map(function(x)
  {return map(function(y){return [y,x]} ,sentenceForms)}, quantifiers),true)

var premiseForms = {"1":[["B","A"],["C","B"]],
                  "2":[["A","B"],["C","B"]],
                  "3":[["B","A"],["B","C"]],
                  "4":[["A","B"],["B","C"]]}

var scholasticDict = {"all":"A","none":"E","some":"I","not all":"O"}

var premisesToScholasticCode = function(premises){
  var figure = _.invert(premiseForms)[premises[0][0]+','+premises[1][0]]
  var code = map(function(x){return scholasticDict[x[1]]}, premises).join('')
  return code+figure
}


var scholasticCodeToPremises = function(code){
  var invertedDict = _.invert(scholasticDict)
  var p = premiseForms[code[2]]
  var premise1 = [p[0], invertedDict[code[0]]]
  var premise2 = [p[1], invertedDict[code[1]]]
  return [premise1, premise2]
}


// var isPremise = function(sentence,figure,premiseNo){
//   return sentence[0] == premiseForms[figure][premiseNo-1]
// }

var isPremise1 = function(x){
  return ((x[0][0]=='A' || x[0][0]=='B') && (x[0][1]=='A' || x[0][1]=='B'))
}

var isPremise2 = function(x){
  return ((x[0][0]=='C' || x[0][0]=='B') && (x[0][1]=='C' || x[0][1]=='B'))
}

var isConclusion = function(x){
//  return (x[0][0]=='A' || x[0][0]=='C') && (x[0][1]=='A' || x[0][1]=='C')
//  return (x[0][0]=='A') && (x[0][1]=='C')
  return (x[0][0]=='C') && (x[0][1]=='A')
}


var stateToSentence = function(state){
  return filter(function(x){return state[syllogisticSentences.indexOf(x)]
  }, syllogisticSentences)
}

var flattenSentences = function(sentences){
  return map(function(sentence){
    return [sentence[0][0], sentence[0][1], sentence[1]].join()
  },sentences)
}



var syllogisticPremisesNested = map(function(x)
  {return map(function(y)
    {return map(function(q1)
      {return map(function(q2)
        {return [[y,q1],[x,q2]]},
        quantifiers)},
      quantifiers)},
    sentenceForms.slice(0,2))},
  sentenceForms.slice(2,4))

var syllogisticPremises = _.flatten(
  _.flatten(
    _.flatten(syllogisticPremisesNested,
      true),
    true),
  true)


var premiseDictionary = {"1": _.flatten(_.flatten(syllogisticPremisesNested,true)[3],true),
                          "2": _.flatten(_.flatten(syllogisticPremisesNested,true)[2],true),
                          "3": _.flatten(_.flatten(syllogisticPremisesNested,true)[1],true),
                          "4": _.flatten(_.flatten(syllogisticPremisesNested,true)[0],true)}


var allOverObjectVals = function(fn, obj)
  {return all(function(kv){return fn(kv[1])}, _.pairs(obj))}

var anyOverObjectVals = function(fn, obj)
  {return any(function(kv){return fn(kv[1])}, _.pairs(obj))}

var allSentence = function(propObject, termOne, termTwo){
  return allOverObjectVals(function(val){return hasProperty(val,termOne)? hasProperty(val,termTwo) : 1},
    propObject)
}

var someSentence = function(propObject, termOne, termTwo){
  return anyOverObjectVals(function(val){return hasProperty(val,termOne)? hasProperty(val,termTwo) : 0},
    propObject)
}

var notallSentence = function(propObject, termOne, termTwo){
  return 1 - allSentence(propObject,termOne,termTwo)
}

var noneSentence = function(propObject, termOne, termTwo){
  return 1 - someSentence(propObject,termOne,termTwo)
}

var mu = function(propObject, termOne, termTwo){
  return 1
}

// quantifier logic and helpers

var hasProperty = function(props,term)
  {return props[propertyOrder.indexOf(term)]}

// equivalence class transformation

var multinomialProbabilities = function(br){
  return [Math.pow(1-br,3),Math.pow(1-br,2)*br,Math.pow(1-br,2)*br,Math.pow(br,2)*(1-br),
          Math.pow(1-br,2)*br,Math.pow(br,2)*(1-br),Math.pow(br,2)*(1-br),Math.pow(br,3)]
}

var pruneERP = function(myERP){
  var scr = map(function(lst)
                 {var y = myERP.score([],lst);
                  return y},
                 myERP.support())
  
  var prnScr=filter(function(lst){return lst[0] > -Infinity}, _.zip(scr,myERP.support()))
  var ps = map(function(x){return Math.exp(first(x))}, prnScr)
  var vs = map(second,prnScr)
  return Enumerate(function(){return vs[discrete(ps)]});
}


/// helpers for sentences

var flattenSentences = function(sentences){
    return map(function(sentence){
      return [sentence[0][0], sentence[0][1], sentence[1]].join()
    },sentences)
  }

// var binarizeConclusionSet = function(trueConcl){
//   return map(function(conclusion){
//     return (flattenSentences(trueConcl).indexOf(conclusion) > -1) ? 1 : 0
//   }, flattenSentences(conclusionOrder)).join('')
// }


var conclusionTrue = function(conclusion, trueSentences){
      var flattenedSentences = flattenSentences(trueSentences) 
      var cnclTrue = flattenedSentences.indexOf(conclusion.join())!=-1
      return cnclTrue
}



var premisesTrue = function(premises, trueSentences){
      var flattenedSentences = flattenSentences(trueSentences) 
      var premsTrue = flattenedSentences.indexOf(premises[0].join())!=-1 &&
                          flattenedSentences.indexOf(premises[1].join())!=-1
      return premsTrue
}


// this considers "multiple conclusions" explicitly
var trueLists = function(trueConcls){
      _.flatten([map(function(x){return flattenSentences(conclusionListOrder).indexOf(x)}, 
                    flattenSentences(trueConcls)), 
                 flattenSentences(conclusionListOrder).indexOf(flattenSentences(trueConcls).join())])
}


