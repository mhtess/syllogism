

var getProperties = function(obj, backgroundPrior) {
  var p = propertyTuples[discrete(backgroundPrior)]
  return p
}

var equivalentTransform = cache(function(objects, theta){
var plentifulWorlds = function(propObject){
  var pO = map(second,_.pairs(propObject)) // function designed for list of lists
  var fOR = function(v1,v2){
    return map2(function(e1,e2){return e1 || e2}, v1, v2)
  }
  return reduce(function(e1,e2){return e1 && e2}, 1, (reduce(fOR,[0,0,0],pO)))
}

//  var backgroundPrior = [1,1,1,1,1,1,1,1]
 var backgroundPrior = _.isArray(theta) ? theta : multinomialProbabilities(theta)
 // console.log(theta)
  Enumerate(function(){
    var propertiesOfObjects = _.object(
      _.zip(
        objects,
        map(function(x){return getProperties(x, backgroundPrior)}
          ,objects)
        )
      )

    var meaning = function(quantifier) {
      return quantifier=="all"? allSentence :
             quantifier=="some"? someSentence :
             quantifier=="none"? noneSentence :
             quantifier=="not all"? notallSentence : 
             true
    }

    var nonEmptyWorld = plentifulWorlds(propertiesOfObjects) 
    factor(nonEmptyWorld?0:-Infinity)

    return map(function(sentence)
      {return meaning(sentence[1])(propertiesOfObjects,
                                    sentence[0][0],
                                    sentence[0][1])}, 
      syllogisticSentences)
  })
})

// var equivalentTransform = function(objects, theta){
//  var propertyWeights = _.isArray(theta) ? theta : multinomialProbabilities(theta)
//  var backgroundPrior = _.object(_.zip(propertyTuples, propertyWeights))

//  var relationWeights = [syllUtils.allAB_EI(objects, empiricalPrior, "A", "B"),
//                         syllUtils.noAB_EI(objects, empiricalPrior, "A", "B"),
//                         1-syllUtils.allAB_EI(objects, empiricalPrior, "A", "B")-
//                           syllUtils.noAB_EI(objects, empiricalPrior, "A", "B")]

                          
//  Enumerate(function(){



//     var propertiesOfObjects = _.object(
//       _.zip(
//         objects,
//         map(function(x){return getProperties(x, backgroundPrior)}
//           ,objects)
//         )
//       )

//     var meaning = function(quantifier) {
//       return quantifier=="all"? allSentence :
//              quantifier=="some"? someSentence :
//              quantifier=="none"? noneSentence :
//              quantifier=="not all"? notallSentence : 
//              true
//     }

//     var nonEmptyWorld = plentifulWorlds(propertiesOfObjects) 
//     factor(nonEmptyWorld?0:-Infinity)

//     return map(function(sentence)
//       {return meaning(sentence[1])(propertiesOfObjects,
//                                     sentence[0][0],
//                                     sentence[0][1])}, 
//       syllogisticSentences)
//   })
// }