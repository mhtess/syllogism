var syllogisticRSA = function(prems, baseRate, objects, speakerOptimality, opts){

  // baseRate ~ uniform(0,1)
  // objects ~ uniformDraw(_.range(2, 15))
  // speakerOptimality ~ uniform(0,20)

  var pragmaticProduction = opts["pragmaticProduction"]
  var pragmaticInterpretation = opts["pragmaticInterpretation"]
  var QUD_E1 = opts["QUD_E1"]
  var QUD_cL0 = opts["QUD_cL0"]

  // pragmaticInterpretation ~ flip(0.5)
  // pragmaticProduction ~ flip(0.5)
  // QUD_E1 ~ uniformDraw(["state","conclusion"])
  // QUD_cL0 ~ uniformDraw(["state","premises"])

  var multinomialProbs = multinomialProbabilities(baseRate)
  var prior = pruneERP(equivalentTransform(objects, multinomialProbs))

  // FIX ME: not fully implemented
  var premises = {
                  utterances: prems,
                  figure: _.invert(premiseForms)[prems[0][0]+','+prems[1][0]]
                 }

  var conclusionListener = cache(function(conclusion, prior, QUD_cL0){
    Enumerate(function(){
      var state = sample(prior)
      var trueSentences = stateToSentence(state)
      // var trueConclusions = filter(isConclusion, trueSentences)
      var firstPremises = filter(isPremise1, trueSentences)
      var secondPremises = filter(isPremise2, trueSentences)

      var premise1 = uniformDraw(firstPremises)
      var premise2 = uniformDraw(secondPremises)

      factor(conclusionTrue(conclusion, trueSentences) ? 0 : -Infinity)

      return QUD_cL0=="state" ? state : [premise1, premise2]
      // return 
    })
  })


  var reasoner0 = cache(function(premises, prior, QUD_E1) {
    Enumerate(function(){

      var state = sample(prior)
      // mapping from worlds to sentences, conclusions
      var trueSentences = stateToSentence(state)
      var trueConclusions = filter(isConclusion, trueSentences)
      var conclusion = uniformDraw(trueConclusions)

      // var listConclusions = trueLists(trueConclusions)
      // var whichConclusions = uniformDraw(listConclusions)

      factor(premisesTrue(premises, trueSentences) ? 0 : -Infinity)

      return QUD_E1=="state" ? state : conclusion 
    })
  })


  var experimenter1 = cache(function(QUDval, prior, QUD_E1) {
    Enumerate(function(){
  //    var premises = uniformDraw(premiseDictionary[figure])
      var premises = uniformDraw(syllogisticPremises)
      var R0 = reasoner0(premises, prior, QUD_E1)
      factor(R0.score([],QUDval))
      return premises
    })
  })

  var reasoner1 = function(premises, prior, QUD_E1, QUD_cL0) {
    Enumerate(function(){
      var state = sample(prior)
      // mapping from worlds to sentences, conclusions
      var trueSentences = stateToSentence(state)
      var trueConclusions = filter(isConclusion, trueSentences)
      var conclusion = uniformDraw(trueConclusions)
      // var listConclusions = trueLists(trueConclusions)

      var qudVal_E1 = (QUD_E1=="state") ? state : conclusion
      var E1 = pragmaticInterpretation ? 
                experimenter1(qudVal_E1, prior, QUD_E1) : 0

      factor(pragmaticInterpretation ? 
              speakerOptimality*E1.score([],premises) : 
              premisesTrue(premises, trueSentences) ? 0 : -Infinity)

      var qudVal_cL0 = (QUD_cL0=="state") ? state : premises
      var cL0 = pragmaticProduction ? 
            conclusionListener(conclusion, prior, QUD_cL0) : 0
      factor(pragmaticProduction ? cL0.score([], qudVal_cL0) : 0)

      return conclusion // what is the conclusion?
      // return whichConclusions // which conclusions are true?
    })
  }

  // return conclusionListener([["C","A"],"all"], prior, QUD_cL0)
  // return reasoner0(prems, prior, QUD_E1)
  // return experimenter1([["C","A"],"all"], prior, QUD_E1)
  // return experimenter1([1,1,1,0,1,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,1,0,1],
  //                       prior, QUD_E1)
  return reasoner1(prems, prior, QUD_E1, QUD_cL0)

}



