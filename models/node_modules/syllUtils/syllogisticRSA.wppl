var syllogisticRSA = function(baseRate, objects, speakerOptimality, opts){

  // baseRate ~ uniform(0,1)
  // objects ~ uniformDraw(_.range(2, 15))
  // speakerOptimality ~ uniform(0,20)

  var pragmaticProduction = opts["pragmaticProduction"]
  var pragmaticInterpretation = opts["pragmaticInterpretation"]
  var QUD_E1 = opts["QUD_E1"]
  var QUD_cL0 = opts["QUD_cL0"]

  // pragmaticInterpretation ~ flip(0.5)
  // pragmaticProduction ~ flip(0.5)
  // QUD_E1 ~ uniformDraw(["state","conclusion"])
  // QUD_cL0 ~ uniformDraw(["state","premises"])

  var multinomialProbs = multinomialProbabilities(baseRate)
  var prior = pruneERP(equivalentTransform(objects, multinomialProbs))

  var premises = {
                  utterances: prems,
                  figure: _.invert(premiseForms)[prems[0][0]+','+prems[1][0]]
                 }

  var reasoner0_naive = cache(function(premises, br, domain) {
    Enumerate(function(){

      var equivalentWorlds = equivalentTransform(objects, multinomialProbabilities(br))

      var state = sample(equivalentWorlds)
      var trueSentences = stateToSentence(state)
          // this could probably be optimized

      var trueConclusions = filter(isConclusion, trueSentences)

      var listConclusions = trueLists(trueConclusions)
  //    var whichConclusions = binarizedConclusionSet[uniformDraw(listConclusions)]
     var whichConclusions = uniformDraw(listConclusions)
  //    var conclusion = uniformDraw(trueConclusions)

      factor(premisesTrue?0:-Infinity)
  //    return conclusion // what is the conclusion?
      return whichConclusions // which conclusions are true?
    })
  })


  var experimenter1_naive = cache(function(QUDval, figure, br) {
    Enumerate(function(){
  //    var premises = uniformDraw(premiseDictionary[figure])
      var premises = uniformDraw(syllogisticPremises)

      var R0 = reasoner0_naive(premises, br)

      factor(R0.score([],QUDval))
      return premises
    })
  })

  var reasoner1 = function(premises) {
    Enumerate(function(){
      var state = sample(prior)
      // mapping from worlds to sentences, conclusions
      var trueSentences = stateToSentence(state)
      var trueConclusions = filter(isConclusion, trueSentences)
      var conclusion = uniformDraw(trueConclusions)
      // var listConclusions = trueLists(trueConclusions)

      var E1 = pragmaticInterpretation ? experimenter1(conclusion, state) : 0
      factor(pragmaticInterpretation ? speakerOptimality*E1.score([],premises) : 
                                       premisesTrue(premises, trueSentences) ? 0 : -Infinity)

      var qudVal = (QUD_cL0=="state") ? state : premises
      var cL0 = pragmaticProduction ? conclusionListener(conclusion) : 0
      factor(pragmaticProduction ? cL0.score([], qudVal) : 0)

      return conclusion // what is the conclusion?
      // return whichConclusions // which conclusions are true?
    })
  }

  return reasoner1(premises)

}



