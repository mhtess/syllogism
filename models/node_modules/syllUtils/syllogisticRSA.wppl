var syllogisticRSA = function(prems, cncl, params, opts, priorParams){

  // baseRate ~ uniform(0,1)
  // objects ~ uniformDraw(_.range(2, 15))
  // speakerOptimality ~ uniform(0,20)
  var speakerOptimality_E1 = params["speakerOptimality_E1"]
  var speakerOptimality_cL0 = params["speakerOptimality_cL0"]
  var cost = params["cost"]

  var pragmaticProduction = opts["pragmaticProduction"]
  var pragmaticInterpretation = opts["pragmaticInterpretation"]
  var QUD_E1 = opts["QUD_E1"]
  var QUD_cL0 = opts["QUD_cL0"]

  var figure  = termsToFigure[prems[0][0].join('') +  prems[1][0].join('')]


  var baseRate = priorParams["baseRate"]
  var objects = priorParams["objects"]
  var empiricalPrior = priorParams["empiricalPrior"]

  // pragmaticInterpretation ~ flip(0.5)
  // pragmaticProduction ~ flip(0.5)
  // QUD_E1 ~ uniformDraw(["state","conclusion"])
  // QUD_cL0 ~ uniformDraw(["state","premises"])
  // var multinomialProbs = multinomialProbabilities(baseRate)
  // console.log(objects, multinomialProbs)

  var prior = baseRate==null ? 
        pruneERP(equivalentTransform(objects, empiricalPrior)):
        pruneERP(equivalentTransform(objects, baseRate))
  // console.log(map(function(x){return Math.exp(prior.score([],x))},prior.support()))
  // FIX ME: not fully implemented
  var premises = {
                  utterances: prems,
                  figure: _.invert(premiseForms)[prems[0][0]+','+prems[1][0]]
                 }

  var conclusionListener = cache(function(conclusion, prior, QUD_cL0){
    Enumerate(function(){
      var state = sample(prior)
      var trueSentences = stateToSentence(state)
      // var trueConclusions = filter(isConclusion, trueSentences)
      var firstPremises = filter(isPremise1, trueSentences)
      var secondPremises = filter(isPremise2, trueSentences)

      var premise1 = uniformDraw(firstPremises)
      var premise2 = uniformDraw(secondPremises)

      factor(conclusionTrue(conclusion, trueSentences) ? 0 : -Infinity)
      // factor(conclusion ? 0 : -Infinity)

      return QUD_cL0=="state" ? state : [premise1, premise2]
      // return 
    })
  })


  var reasoner0 = cache(function(premises, cncl, prior, QUD_E1) {
    Enumerate(function(){

      var state = sample(prior)
      // mapping from worlds to sentences, conclusions
      var trueSentences = stateToSentence(state)
      // var conclusionTrue = syllUtils.containsObject(cncl, trueSentences)
      // var ct = conclusionTrue(cncl, trueSentences)
      // var utteranceProbs = ct ? [1,cost] : [1, 0]
      // var conclusion = [["mu"],cncl][discrete(utteranceProbs)]

      // var conclusion = uniformDraw(utterances)

      var trueConclusions = filter(isConclusion, trueSentences)
      var conclusion = uniformDraw(trueConclusions)

      // var listConclusions = trueLists(trueConclusions)
      // var whichConclusions = uniformDraw(listConclusions)

      factor(premisesTrue(premises, trueSentences) ? 0 : -Infinity)

      // return QUD_E1=="state" ? state : conclusion
      // return QUD_E1=="state" ? state : conclusionTrue
      return conclusion
      // return ct
    })
  })

  var experimenter1 = cache(function(QUDval, prior, QUD_E1, cncl) {
    Enumerate(function(){

     var premises = uniformDraw(premiseDictionary[figure])
      // var premises = uniformDraw(syllogisticPremises)
      var R0 = reasoner0(premises, cncl, prior, QUD_E1)
      factor(R0.score([],QUDval))
      return premises
    })
  })

  // var pragmaticReasoner = function(premises, CArelation, prior, QUD_E1, QUD_cL0) {
  //   Enumerate(function(){
  //     var state = sample(prior)
  //     // mapping from worlds to sentences, conclusions
  //     var trueSentences = stateToSentence(state)
  //     var ct = conclusionTrue(CArelation, trueSentences)
  //     var utteranceProbs = ct ? [1,cost] : [1, 0]
  //     var conclusion = [["mu"],CArelation][discrete(utteranceProbs)]

  //     var qudVal_E1 = (QUD_E1=="state") ? state : conclusion
  //     var E1 = pragmaticInterpretation ? 
  //               experimenter1(qudVal_E1, prior, QUD_E1, CArelation) : 0

  //     factor(pragmaticInterpretation ? 
  //             speakerOptimality_E1*E1.score([],premises) : 
  //             premisesTrue(premises, trueSentences) ? 0 : -Infinity)


var pragmaticInterpreter = cache(function(premises, prior, QUD_E1){
  Enumerate(function(){
    var state = sample(prior)
    var trueSentences = stateToSentence(state)
    var trueConclusions = filter(isConclusion, trueSentences)
    var CArelation = uniformDraw(trueConclusions)

    var qudVal_E1 = (QUD_E1=="state") ? state : CArelation
    var E1 = pragmaticInterpretation ? 
                experimenter1(qudVal_E1, prior, QUD_E1, cncl) : 0

    factor(pragmaticInterpretation ? 
           speakerOptimality_E1*E1.score([],premises) : 
           premisesTrue(premises, trueSentences) ? 0 : -Infinity)

    return CArelation
    })
})


  // var reasoner1 = function(premises, prior, QUD_E1, QUD_cL0) {
  var pragmaticReasoner = function(premises, cncl, prior, QUD_E1, QUD_cL0) {
    Enumerate(function(){

      var interpretedRelations = pragmaticInterpreter(premises, prior, QUD_E1)

      var utteranceProbs = [cost, Math.exp(interpretedRelations.score([], cncl))]
      // var ct = conclusionTrue(cncl, trueSentences)
      // var utteranceProbs = ct ? [1,cost] : [1, 0]
      var conclusion = [["mu"],cncl][discrete(utteranceProbs)]

      // var qudVal_cL0 = (QUD_cL0=="state") ? state : premises
      var qudVal_cL0 = premises
      var cL0 = pragmaticProduction ? 
            conclusionListener(conclusion, prior, QUD_cL0) : 0
      factor(pragmaticProduction ? 
              speakerOptimality_cL0*cL0.score([], qudVal_cL0) : 0)

      // return only quantifier
      return !(conclusion[0]=="mu") // true or false?
       // what is the conclusion?
      // return whichConclusions // which conclusions are true?
    })
  }

  // return conclusionListener([["C","A"],"all"], prior, QUD_cL0)
  // return reasoner0(prems,cncl, prior, QUD_E1)
  // return experimenter1([["C","A"],"all"], prior, QUD_E1)
  // return experimenter1([1,1,1,0,1,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,1,0,1],
  //                       prior, QUD_E1)
  // return reasoner1(prems, prior, QUD_E1, QUD_cL0)
  return pragmaticReasoner(prems, cncl, prior, QUD_E1, QUD_cL0)

 // return figure

}



