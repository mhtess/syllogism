var syllogisticRSA = function(baseRate, objects, speakerOptimality, opts){

  // baseRate ~ uniform(0,1)
  // objects ~ uniformDraw(_.range(2, 15))
  // speakerOptimality ~ uniform(0,20)

  var pragmaticProduction = opts["pragmaticProduction"]
  var pragmaticInterpretation = opts["pragmaticInterpretation"]
  var QUD_E1 = opts["QUD_E1"]
  var QUD_cL0 = opts["QUD_cL0"]

  // pragmaticInterpretation ~ flip(0.5)
  // pragmaticProduction ~ flip(0.5)
  // QUD_E1 ~ uniformDraw(["state","conclusion"])
  // QUD_cL0 ~ uniformDraw(["state","premises"])

  var multinomialProbs = multinomialProbabilities(baseRate)
  var prior = pruneERP(equivalentTransform(objects, multinomialProbs))

  var premises = {
                  utterances: prems,
                  figure: _.invert(premiseForms)[prems[0][0]+','+prems[1][0]]
                 }

  

  var reasoner0 = cache(function(premises) {
    Enumerate(function(){

      var state = sample(prior)
      // mapping from worlds to sentences, conclusions
      var trueSentences = stateToSentence(state)
      var trueConclusions = filter(isConclusion, trueSentences)
      var conclusion = uniformDraw(trueConclusions)

      // var listConclusions = trueLists(trueConclusions)
      // var whichConclusions = uniformDraw(listConclusions)

      factor(premisesTrue(premises, trueSentences) ? 0 : -Infinity)

      return QUD_E1=="state" ? state : conclusion 
    })
  })


  var experimenter1 = cache(function(QUDval) {
    Enumerate(function(){
  //    var premises = uniformDraw(premiseDictionary[figure])
      var premises = uniformDraw(syllogisticPremises)
      var R0 = reasoner0(premises)
      factor(R0.score([],QUDval))
      return premises
    })
  })

  var reasoner1 = function(premises) {
    Enumerate(function(){
      var state = sample(prior)
      // mapping from worlds to sentences, conclusions
      var trueSentences = stateToSentence(state)
      var trueConclusions = filter(isConclusion, trueSentences)
      var conclusion = uniformDraw(trueConclusions)
      // var listConclusions = trueLists(trueConclusions)

      var qudVal_E1 = (QUD_E1=="state") ? state : conclusion
      var E1 = pragmaticInterpretation ? experimenter1(qudVal_E1) : 0
      factor(pragmaticInterpretation ? speakerOptimality*E1.score([],premises) : 
                                       premisesTrue(premises, trueSentences) ? 0 : -Infinity)

      var qudVal_cL0 = (QUD_cL0=="state") ? state : premises
      var cL0 = pragmaticProduction ? conclusionListener(conclusion) : 0
      factor(pragmaticProduction ? cL0.score([], qudVal_cL0) : 0)

      return conclusion // what is the conclusion?
      // return whichConclusions // which conclusions are true?
    })
  }

  return reasoner1(premises)

}



