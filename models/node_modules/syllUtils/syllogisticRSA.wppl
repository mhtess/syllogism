var syllogisticRSA = function(prems, params, opts, prior){

  // baseRate ~ uniform(0,1)
  // objects ~ uniformDraw(_.range(2, 15))
  // speakerOptimality ~ uniform(0,20)
  var speakerOptimality_E1 = params["speakerOptimality_E1"]
  var speakerOptimality_cL0 = params["speakerOptimality_cL0"]
  var cost = params["cost"]

  var pragmaticProduction = opts["pragmaticProduction"]
  var pragmaticInterpretation = opts["pragmaticInterpretation"]
  var QUD_E1 = opts["QUD_E1"]
  var QUD_cL0 = opts["QUD_cL0"]

  var figure  = termsToFigure[prems[0][0].join('') +  prems[1][0].join('')]

  // var baseRate = priorParams["baseRate"]
  // var n_objects = priorParams["n_objects"]
  // var empiricalPrior = priorParams["empiricalPrior"]

  // pragmaticInterpretation ~ flip(0.5)
  // pragmaticProduction ~ flip(0.5)
  // QUD_E1 ~ uniformDraw(["state","conclusion"])
  // QUD_cL0 ~ uniformDraw(["state","premises"])
  // var multinomialProbs = multinomialProbabilities(baseRate)
  // console.log(objects, multinomialProbs)

  // var prior = baseRate==null ? 
  //       pruneERP(equivalentTransform(objects, empiricalPrior)):
  //       pruneERP(equivalentTransform(objects, baseRate))
  // console.log(map(function(x){return Math.exp(prior.score([],x))},prior.support()))
  // FIX ME: not fully implemented
  // var premises = {
  //                 utterances: prems,
  //                 figure: _.invert(premiseForms)[prems[0][0]+','+prems[1][0]]
  //                }

  // var prior = possiblePriors[n_objects][baseRate]

  var conclusionListener = cache(function(conclusion, prior, QUD_cL0){
    Enumerate(function(){
      var state = sample(prior)
      var trueSentences = stateToSentence(state)
      // var trueConclusions = filter(isConclusion, trueSentences)
      var firstPremises = filter(isPremise1, trueSentences)
      var secondPremises = filter(isPremise2, trueSentences)

      var premise1 = uniformDraw(firstPremises)
      var premise2 = uniformDraw(secondPremises)

      // be able to handle pairs of conclusions (e.g. all + some)
      var conditioner = _.isArray(conclusion[1]) ? 
        (conclusionTrue(conclusion[0], trueSentences) && 
          conclusionTrue(conclusion[1], trueSentences)):
        conclusionTrue(conclusion, trueSentences)

      factor(conditioner ? 0 : -Infinity)
      // factor(conclusion ? 0 : -Infinity)

      return QUD_cL0=="state" ? state : [premise1, premise2]
      // return 
    })
  })


  var reasoner0 = cache(function(premises, prior, QUD_E1) {
    Enumerate(function(){

          var t0 = mht.getTime()
      var state = sample(prior)
          var t1 = mht.getTime()
    console.log("sample(prior) = " + (t1-t0))
      // mapping from worlds to sentences, conclusions
      var trueSentences = stateToSentence(state)
      // var conclusionTrue = syllUtils.containsObject(cncl, trueSentences)
      // var ct = conclusionTrue(cncl, trueSentences)
      // var utteranceProbs = ct ? [1,cost] : [1, 0]
      // var conclusion = [["mu"],cncl][discrete(utteranceProbs)]

      // var conclusion = uniformDraw(utterances)

      var trueConclusions = filter(isConclusion, trueSentences)
      // var conclusion = uniformDraw(trueConclusions)
      var conclusion = [trueConclusions[0], 
                        trueConclusions[1],
                        trueConclusions][discrete([1,1,0.5])]

      // var listConclusions = trueLists(trueConclusions)
      // var whichConclusions = uniformDraw(listConclusions)

      // condition((premises == "null utterance") ? true : premisesTrue(premises, trueSentences))
      factor(premisesTrue(premises, trueSentences) ? 0 : -Infinity)

      return QUD_E1=="state" ? state : conclusion
      // return QUD_E1=="state" ? state : conclusionTrue
      // return conclusion
      // return ct
    })
  })

  var experimenter1 = cache(function(QUDval, prior, QUD_E1) {
    Enumerate(function(){

     var premises = uniformDraw(premiseDictionary[figure])
     // var premises = uniformDraw([prems, "null utterance"])
      // var premises = uniformDraw(syllogisticPremises)

      var R0 = reasoner0(premises, prior, QUD_E1)



      factor(R0.score([],QUDval))
      return premises
    })
  })

  // var pragmaticReasoner = function(premises, CArelation, prior, QUD_E1, QUD_cL0) {
  //   Enumerate(function(){
  //     var state = sample(prior)
  //     // mapping from worlds to sentences, conclusions
  //     var trueSentences = stateToSentence(state)
  //     var ct = conclusionTrue(CArelation, trueSentences)
  //     var utteranceProbs = ct ? [1,cost] : [1, 0]
  //     var conclusion = [["mu"],CArelation][discrete(utteranceProbs)]

  //     var qudVal_E1 = (QUD_E1=="state") ? state : conclusion
  //     var E1 = pragmaticInterpretation ? 
  //               experimenter1(qudVal_E1, prior, QUD_E1, CArelation) : 0

  //     factor(pragmaticInterpretation ? 
  //             speakerOptimality_E1*E1.score([],premises) : 
  //             premisesTrue(premises, trueSentences) ? 0 : -Infinity)


// var pragmaticInterpreter = cache(function(premises, prior, QUD_E1){
//   Enumerate(function(){
//     var state = sample(prior)
//     var trueSentences = stateToSentence(state)
//     var trueConclusions = filter(isConclusion, trueSentences)
//     var CArelation = uniformDraw(trueConclusions)

//     var qudVal_E1 = (QUD_E1=="state") ? state : CArelation
//     var E1 = pragmaticInterpretation ? 
//                 experimenter1(qudVal_E1, prior, QUD_E1, cncl) : 0

//     factor(pragmaticInterpretation ? 
//            speakerOptimality_E1*E1.score([],premises) : 
//            premisesTrue(premises, trueSentences) ? 0 : -Infinity)

//     return CArelation
//     })
// })


  // var reasoner1 = function(premises, prior, QUD_E1, QUD_cL0) {
  var pragmaticReasoner = function(premises, prior, QUD_E1, QUD_cL0) {
    Enumerate(function(){
      var state = sample(prior)
      var trueSentences = stateToSentence(state)
      var trueConclusions = filter(isConclusion, trueSentences)

      var conclusion = [trueConclusions[0], 
                        trueConclusions[1],
                        trueConclusions][discrete([1,1,0.5])]

      // var conclusion = uniformDraw(trueConclusions)

      var qudVal_E1 = (QUD_E1=="state") ? state : conclusion
    // var t0 = mht.getTime()

      var E1 = pragmaticInterpretation ? 
                  experimenter1(qudVal_E1, prior, QUD_E1) : 0
    // var t1 = mht.getTime()
    // console.log("E1 call = " + (t1-t0))

      factor(pragmaticInterpretation ? 
             speakerOptimality_E1*E1.score([],premises) : 
             premisesTrue(premises, trueSentences) ? 0 : -Infinity)

      // var utteranceProbs = [cost, Math.exp(interpretedRelations.score([], cncl))]

      // var ct = conclusionTrue(cncl, trueSentences)
      // var utteranceProbs = ct ? [1,cost] : [1, 0]
      // var conclusion = [["mu"],cncl][discrete(utteranceProbs)]

      var qudVal_cL0 = (QUD_cL0=="state") ? state : premises
      // var qudVal_cL0 = premises
      var cL0 = pragmaticProduction ? 
            conclusionListener(conclusion, prior, QUD_cL0) : 0
      factor(pragmaticProduction ? 
              speakerOptimality_cL0*cL0.score([], qudVal_cL0) : 0)

      // return only quantifier
      // return !(conclusion[0]=="mu") // true or false?
      return conclusion
       // what is the conclusion?
      // return whichConclusions // which conclusions are true?
    })
  }

  // console.log(prems)
  // return conclusionListener([["C","A"],"all"], prior, QUD_cL0)
  // return reasoner0(prems, prior, QUD_E1)
  // return experimenter1([["C","A"],"all"], prior, QUD_E1)
  // return experimenter1([1,1,1,0,1,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,1,0,1],
  //                       prior, QUD_E1)
  // return reasoner1(prems, prior, QUD_E1, QUD_cL0)
  return pragmaticReasoner(prems, prior, QUD_E1, QUD_cL0)
 // return figure

}



