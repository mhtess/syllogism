var quantifiers = ["all","some","none", "not all"];
var sentenceForms = [ ["A","B"],["B","A"],
                      ["B","C"],["C","B"],
                      ["A","C"],["C","A"]];

var syllogisticSentences = _.flatten(map(
  function(x){ 
    return map(
      function(y){ 
        return {terms: y,
            quantifier: x}
      } ,sentenceForms)
  }, quantifiers))

var first_premises = filter(isPremise1, syllogisticSentences)
var second_premises = filter(isPremise2, syllogisticSentences)

var syllogismPrior = Enumerate(function(){
    var premise_1 = uniformDraw(first_premises)
    var premise_2 = uniformDraw(second_premises)
    return [premise_1, premise_2]
})

// [0, 1, 1, 2, 1, 2, 2, 3]
var property_values = [[0,0,0],[0,0,1],[0,1,0],[0,1,1],
                       [1,0,0],[1,0,1],[1,1,0],[1,1,1]]



// equivalence class transformation
var equivalenceTransform = cache(function(probs, n){
  Enumerate(function(){

    var objects = multinomial(probs, n)
    var objects_w_values = _.zip(objects, property_values)
    var world = map(second, filter(function(o){
      return o[0]
    }, objects_w_values))

    ///////////////////////////////////////
    // existential presupposition condition
    // condition(plentifulWorlds(world))
    ///////////////////////////////////////

    // returns list of truth values
    // return map(function(sentence){
    //   return meaning(sentence.quantifier)(world, sentence.terms[0], sentence.terms[1])
    // }, syllogisticSentences)

    // returns list of sentence objects, with truthValue property
    return map(function(sentence){
      return _.extend(
          _.clone(sentence),
          {truthValue: meaning(sentence.quantifier)(world, sentence.terms[0], sentence.terms[1])}
          )
    }, syllogisticSentences)
  })
})

