var shape_alpha = function(g,d){return g * d}
var shape_beta = function(g,d){return (1-g) * d}

var discretizeBeta = function(g, d, bins){
	var betaPDF = function(x){
	  return Math.pow(x,shape_alpha(g,d)-1)*Math.pow((1-x),shape_beta(g,d)-1)
	}
	return map(betaPDF, bins)
}

var softmaxSpeaker = function(speakerERP, softmax){
  Enumerate(function(){
      var supp = speakerERP.support()
      var probs = map(function(s){return Math.exp(softmax*speakerERP.score([],s))}, supp)
      var response = supp[discrete(probs)]
      return response
  })
}

var addGuessing = function(myERP, phi){
    Enumerate(function(){
        var x = flip(1-phi) ? 
                    sample(myERP) :
                    flip(0.5)
                    // uniformDraw(["all","some","not all","none"])

        // return only quantifier
        return x
    })
}


var hasProperty = function(props,term){
  return props[["A","B","C"].indexOf(term)]
}

var allOverObjectVals = function(fn, obj){
  return all(
    function(kv){return fn(kv)}, 
    obj)
}

var anyOverObjectVals = function(fn, obj){
  return any(
    function(kv){return fn(kv)}, 
    obj)
}

var allSentence = function(propObject, termOne, termTwo){
  return allOverObjectVals(
    function(val){
      return hasProperty(val,termOne)? hasProperty(val,termTwo) : 1
    },propObject)
}

var someSentence = function(propObject, termOne, termTwo){
  return anyOverObjectVals(
    function(val){
      return hasProperty(val,termOne)? hasProperty(val,termTwo) : 0
    },propObject)
}

var notallSentence = function(propObject, termOne, termTwo){
  return 1 - allSentence(propObject,termOne,termTwo)
}

var noneSentence = function(propObject, termOne, termTwo){
  return 1 - someSentence(propObject,termOne,termTwo)
}

var meaning = function(quantifier) {
  return quantifier=="all"? allSentence :
         quantifier=="some"? someSentence :
         quantifier=="none"? noneSentence :
         quantifier=="not all"? notallSentence : 
         true
}

var plentifulWorlds = function(pO){
  // var pO = map(second,_.pairs(propObject)) // function designed for list of lists
  var fOR = function(v1,v2){
    return map2(function(e1,e2){return e1 || e2}, v1, v2)
  }
  return reduce(function(e1,e2){return e1 && e2}, 1, (reduce(fOR,[0,0,0],pO)))
}

var quantifiers = ["all","some","none", "not all"];
var sentenceForms = [ ["A","B"],["B","A"],
                      ["B","C"],["C","B"],
                      ["A","C"],["C","A"]];

var syllogisticSentences = _.flatten(map(
  function(x){ 
    return map(
      function(y){ 
        return {terms: y,
            quantifier: x}
      } ,sentenceForms)
  }, quantifiers))

var probs = [0.125,0.125,0.5,0.125,0.01,0.3,0.1,0.125]
var n = 3

var property_values = [[0,0,0],[0,0,1],[0,1,0],[0,1,1],
                       [1,0,0],[1,0,1],[1,1,0],[1,1,1]]

// equivalence class transformation
var equivalenceTransform = function(probs, n){
  Enumerate(function(){

    var objects = multinomial(probs, n)
    var objects_w_values = _.zip(objects, property_values)
    var world = map(second, filter(function(o){
      return o[0]
    }, objects_w_values))

    // existential presupposition condition
    // condition(plentifulWorlds(world))

    // returns list of truth values
    // return map(function(sentence){
    //   return meaning(sentence.quantifier)(world, sentence.terms[0], sentence.terms[1])
    // }, syllogisticSentences)

    // returns list of sentence objects, with truthValue property
    return map(function(sentence){
      return _.extend(
          _.clone(sentence),
          {truthValue: meaning(sentence.quantifier)(world, sentence.terms[0], sentence.terms[1])}
          )
    }, syllogisticSentences)
  })
}
