var shape_alpha = function(g,d){return g * d}
var shape_beta = function(g,d){return (1-g) * d}

var discretizeBeta = function(g, d, bins){
	var betaPDF = function(x){
	  return Math.pow(x,shape_alpha(g,d)-1)*Math.pow((1-x),shape_beta(g,d)-1)
	}
	return map(betaPDF, bins)
}

var softmaxSpeaker = function(speakerERP, softmax){
  Enumerate(function(){
      var supp = speakerERP.support()
      var probs = map(function(s){return Math.exp(softmax*speakerERP.score([],s))}, supp)
      var response = supp[discrete(probs)]
      return response
  })
}

var addGuessing = function(myERP, phi){
    Enumerate(function(){
        var x = flip(1-phi) ? 
                    sample(myERP) :
                    // flip(0.5)
                    uniformDraw(["all","some","not all","none"])

        // return only quantifier
        return x
    })
}

var hasProperty = function(props,term){
  return props[["A","B","C"].indexOf(term)]
}

var allOverObjectVals = function(fn, obj){
  return all(
    function(kv){return fn(kv)}, 
    obj)
}

var anyOverObjectVals = function(fn, obj){
  return any(
    function(kv){return fn(kv)}, 
    obj)
}

var allSentence = function(propObject, termOne, termTwo){
  return allOverObjectVals(
    function(val){
      return hasProperty(val,termOne)? hasProperty(val,termTwo) : 1
    },propObject)
}

var allandsomeSentence = function(propObject, termOne, termTwo){
  return allOverObjectVals(
    function(val){
      return hasProperty(val,termOne)? hasProperty(val,termTwo) : 1
    },propObject) && someSentence(propObject, termOne, termTwo)
}


var someSentence = function(propObject, termOne, termTwo){
  return anyOverObjectVals(
    function(val){
      return hasProperty(val,termOne)? hasProperty(val,termTwo) : 0
    },propObject)
}

var notallSentence = function(propObject, termOne, termTwo){
  return 1 - allSentence(propObject,termOne,termTwo)
}

var notallandsomeSentence = function(propObject, termOne, termTwo){
  return 1 - allandsomeSentence(propObject,termOne,termTwo)
}


var noneSentence = function(propObject, termOne, termTwo){
  return 1 - someSentence(propObject,termOne,termTwo)
}

var meaning = function(quantifier) {
  return quantifier=="all"? allandsomeSentence :
         quantifier=="some"? someSentence :
         quantifier=="none"? noneSentence :
         quantifier=="not all"? notallandsomeSentence : 
         true
}

var plentifulWorlds = function(pO){
  // var pO = map(second,_.pairs(propObject)) // function designed for list of lists
  var fOR = function(v1,v2){
    return map2(function(e1,e2){return e1 || e2}, v1, v2)
  }
  return reduce(function(e1,e2){return e1 && e2}, 1, (reduce(fOR,[0,0,0],pO)))
}


var scholasticDict = {"all":"A","none":"E","some":"I","not all":"O"}
var premiseForms = {"1":[["B","A"],["C","B"]],
                  "2":[["A","B"],["C","B"]],
                  "3":[["B","A"],["B","C"]],
                  "4":[["A","B"],["B","C"]]}
                  
var scholasticCodeToPremises = function(code){
  var invertedDict = _.invert(scholasticDict)
  var p = premiseForms[code[2]]
  var premise1 = {terms: p[0], quantifier: invertedDict[code[0]]}
  var premise2 = {terms: p[1], quantifier: invertedDict[code[1]]}
  return [premise1, premise2]
}

// var isPremise1 = function(s){
//   return (_.contains(s.terms, "A") & _.contains(s.terms, "B"))
// }

// var isPremise2 = function(s){
//   return (_.contains(s.terms, "B") & _.contains(s.terms, "C"))
// }

var isPremise1 = function(s){
  return ((s.terms[0]=="B") & (s.terms[1]=="A"))
}

var isPremise2 = function(s){
  return ((s.terms[0]=="C") & (s.terms[1]=="B"))
}

var isConclusion = function(s){
  // return ((s.terms[0]=="A") & (s.terms[1]=="C"))
  return ((s.terms[0]=="C") & (s.terms[1]=="A"))
  // return (_.contains(s.terms, "A") & _.contains(s.terms, "C"))
}

var premisesTrue = function(premises, trueSentences){
  return filter(function(s){
    return (
      _.isEqual(_.omit(s, "truthValue"), premises[0]) || 
      _.isEqual(_.omit(s, "truthValue"), premises[1])
      )
  }, trueSentences).length==2
}


var conclusionTrue = function(conclusion, trueSentences){
  return filter(function(s){
    return _.isEqual(_.omit(s, "truthValue"), conclusion) 
  }, trueSentences).length==1
}

