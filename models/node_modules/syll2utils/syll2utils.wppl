var shape_alpha = function(g,d){return g * d}
var shape_beta = function(g,d){return (1-g) * d}

var discretizeBeta = function(g, d, bins){
	var betaPDF = function(x){
	  return Math.pow(x,shape_alpha(g,d)-1)*Math.pow((1-x),shape_beta(g,d)-1)
	}
	return map(betaPDF, bins)
}

var softmaxSpeaker = function(speakerERP, softmax){
  Enumerate(function(){
      var supp = speakerERP.support()
      var probs = map(function(s){return Math.exp(softmax*speakerERP.score([],s))}, supp)
      var response = supp[discrete(probs)]
      return response
  })
}

var addGuessing = function(myERP, phi){
    Enumerate(function(){
        var x = flip(1-phi) ? 
                    sample(myERP) :
                    flip(0.5)
                    // uniformDraw(["all","some","not all","none"])

        // return only quantifier
        return x
    })
}


var hasProperty = function(props,term){
  return props[["A","B","C"].indexOf(term)]
}

var allOverObjectVals = function(fn, obj){
  return all(
    function(kv){return fn(kv)}, 
    obj)
}

var anyOverObjectVals = function(fn, obj){
  return any(
    function(kv){return fn(kv)}, 
    obj)
}

var allSentence = function(propObject, termOne, termTwo){
  return allOverObjectVals(
    function(val){
      return hasProperty(val,termOne)? hasProperty(val,termTwo) : 1
    },propObject)
}

var allandsomeSentence = function(propObject, termOne, termTwo){
  return allOverObjectVals(
    function(val){
      return hasProperty(val,termOne)? hasProperty(val,termTwo) : 1
    },propObject) && someSentence(propObject, termOne, termTwo)
}


var someSentence = function(propObject, termOne, termTwo){
  return anyOverObjectVals(
    function(val){
      return hasProperty(val,termOne)? hasProperty(val,termTwo) : 0
    },propObject)
}

var notallSentence = function(propObject, termOne, termTwo){
  return 1 - allSentence(propObject,termOne,termTwo)
}

var notallandsomeSentence = function(propObject, termOne, termTwo){
  return 1 - allandsomeSentence(propObject,termOne,termTwo)
}


var noneSentence = function(propObject, termOne, termTwo){
  return 1 - someSentence(propObject,termOne,termTwo)
}

var meaning = function(quantifier) {
  return quantifier=="all"? allandsomeSentence :
         quantifier=="some"? someSentence :
         quantifier=="none"? noneSentence :
         quantifier=="not all"? notallandsomeSentence : 
         true
}

var plentifulWorlds = function(pO){
  // var pO = map(second,_.pairs(propObject)) // function designed for list of lists
  var fOR = function(v1,v2){
    return map2(function(e1,e2){return e1 || e2}, v1, v2)
  }
  return reduce(function(e1,e2){return e1 && e2}, 1, (reduce(fOR,[0,0,0],pO)))
}


