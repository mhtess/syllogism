var argumentStrength_literal = cache(function(premises, prior) {
  Enumerate(function(){
    // console.log(premises)
        // var t0 = mht.getTime()
    var world = sample(prior)
    //   var t1 = mht.getTime()
    // console.log("sample(prior) = " + (t1-t0))

    var trueSentences = filter(function(w){return w.truthValue}, world) // remove false sentences
    var trueConclusions = filter(isConclusion, trueSentences) // grab the conclusions
    var conclusion = uniformDraw(trueConclusions) // uniform draw from true conclusions
    condition(premisesTrue(premises, trueSentences))
    return _.omit(conclusion, "truthValue")
  })
})

var premisesToState_literal = cache(function(premises, prior) {
  Enumerate(function(){
    var world = sample(prior)
    var trueSentences = filter(function(w){return w.truthValue}, world) // remove false sentences
    condition(premisesTrue(premises, trueSentences))
    return world
  })
})


var conclusionToState_literal = cache(function(conclusion, prior) {
  Enumerate(function(){
    var world = sample(prior)
    var trueSentences = filter(function(w){return w.truthValue}, world) // remove false sentences
    condition(conclusion == "null" ? true : conclusionTrue(conclusion, trueSentences))
    return world
  })
})



var conclusionToPremises_literal = cache(function(conclusion, prior) {
  Enumerate(function(){
    var world = sample(prior)
    var premises = sample(syllogismPrior)

    var trueSentences = filter(function(w){return w.truthValue}, world) // remove false sentences
    condition(conclusion == "null" ? true : conclusionTrue(conclusion, trueSentences))
    condition(premisesTrue(premises, trueSentences))

    return premises
  })
})

var stateToConclusion_speaker = cache(function(world, prior, conclusion) {
  Enumerate(function(){
    var utterance = uniformDraw([conclusion, "null"])
    var cts_literal = conclusionToState_literal(utterance, prior)
    factor(cts_literal.score([], world))
    return utterance
  })
})

var conclusionToState_pragmaticListener = cache(function(conclusion, prior, speakerOptimality_E1) {
  Enumerate(function(){
    var world = sample(prior)
    var trueSentences = filter(function(w){return w.truthValue}, world) // remove false sentences
    var stc_speaker = stateToConclusion_speaker(world, prior, conclusion)
    factor(speakerOptimality_E1*stc_speaker.score([], conclusion))
    return world
  })
})

var qudvalToPremises = cache(function(QUDval, prior, qud) {
  Enumerate(function(){
    // var premise_1 = uniformDraw(first_premises)
    // var premise_2 = uniformDraw(second_premises)
    var premises = sample(syllogismPrior)
    var R0 = qud=='conclusion' ? argumentStrength_literal(premises, prior) : 
                                  premisesToState_literal(premises, prior)

    factor(R0.score([],QUDval))
    return premises
  })
})

var premisesToState_pragmatic = cache(function(premises, prior, speakerOptimality_E1){
  Enumerate(function(){
    var world = sample(prior)
    var E1 = qudvalToPremises(world, prior, "state")
    factor(speakerOptimality_E1 * E1.score([], premises))
    return world
  })
})


var argumentStrength_pragmatic = function(premises, prior, speakerOptimality_E1){
  Enumerate(function(){
    var world = sample(prior)
    var trueSentences = filter(function(w){return w.truthValue}, world) // remove false sentences
    var trueConclusions = filter(isConclusion, trueSentences) // grab the conclusions
    var conclusion = uniformDraw(trueConclusions) // uniform draw from true conclusions
    var E1 = qudvalToPremises(world, prior, "state")
    factor(speakerOptimality_E1 * E1.score([], premises))

    // return  _.omit(conclusion, "truthValue")
    return {quantifier: conclusion.quantifier,
            state: world}
  })
}


var argumentStrength_pragmatic_qudC= function(premises, prior, speakerOptimality_E1){
  Enumerate(function(){
    var world = sample(prior)
    var trueSentences = filter(function(w){return w.truthValue}, world) // remove false sentences
    var trueConclusions = filter(isConclusion, trueSentences) // grab the conclusions
    var conclusion = uniformDraw(trueConclusions) // uniform draw from true conclusions
    var E1 = qudvalToPremises( _.omit(conclusion, "truthValue"), prior, "conclusion")
    factor(speakerOptimality_E1 * E1.score([], premises))

    // return  _.omit(conclusion, "truthValue")
    // return {quantifier: conclusion.quantifier,
    //         state: world}

    return conclusion.quantifier
  })
}


var argumentStrength_pragmaticProduction = cache(function(premises, prior){
  Enumerate(function(){
    var world = sample(prior)
    var trueSentences = filter(function(w){return w.truthValue}, world) // remove false sentences
    condition(premisesTrue(premises, trueSentences))

    var trueConclusions = filter(isConclusion, trueSentences) // grab the conclusions
    var conclusion = uniformDraw(trueConclusions) // uniform draw from true conclusions

    var l0 = conclusionToState_literal(_.omit(conclusion, "truthValue"), prior)
    factor(l0.score([], world))

    // return  _.omit(conclusion, "truthValue")
    return {quantifier: conclusion.quantifier,
            state: world}
  })
})

var argumentStrength_pragmaticProduction_qudC =  cache(function(premises, prior){
  Enumerate(function(){
    var world = sample(prior)
    var trueSentences = filter(function(w){return w.truthValue}, world) // remove false sentences
    condition(premisesTrue(premises, trueSentences))

    var trueConclusions = filter(isConclusion, trueSentences) // grab the conclusions
    var conclusion = uniformDraw(trueConclusions) // uniform draw from true conclusions

    var l0 = conclusionToPremises_literal(_.omit(conclusion, "truthValue"), prior)
    factor(l0.score([], premises))

    // return  _.omit(conclusion, "truthValue")
    return {quantifier: conclusion.quantifier,
            state: world}
  })
})




var speaker2 = function(premises, conclusion, prior, speakerOptimality_E1){
  Enumerate(function(){
    // could be a literal interpreter; also QUD could be conclusion
    var worldPosterior = premisesToState_pragmatic(premises, prior, speakerOptimality_E1)

    var world = sample(worldPosterior)
    var trueSentences = filter(function(w){return w.truthValue}, world) // remove false sentences
    var conclusionIsTrue = conclusionTrue(conclusion, trueSentences)


    var utterances = conclusionIsTrue ? ['null', conclusion] : ['null']
    var utterance = uniformDraw(utterances)

    // could be a literal interpreter
    var l1 = conclusionToState_pragmaticListener(utterance, prior, speakerOptimality_E1)
    factor(l1.score([], world))
    return utterance
    // return conclusionIsTrue
  })
}


var speaker2_QUDpremises = function(premises, conclusion, prior, speakerOptimality_E1){
  Enumerate(function(){
    // QUD on premise interpretation is the conclusion
    var worldPosterior = marginalize(argumentStrength_pragmatic(premises, prior, speakerOptimality_E1), "state")

    var world = sample(worldPosterior)
    var trueSentences = filter(function(w){return w.truthValue}, world) // remove false sentences
    var conclusionIsTrue = conclusionTrue(conclusion, trueSentences)


    var utterances = conclusionIsTrue ? ['null', conclusion] : ['null']
    var utterance = uniformDraw(utterances)

    // could be a literal interpreter
    var l1 = conclusionToState_pragmaticListener(utterance, prior, speakerOptimality_E1)
    factor(l1.score([], world))
    return utterance
    // return conclusionIsTrue
  })
}


var speaker2_QUDpremises_cL0 = function(premises, conclusion, prior, speakerOptimality_E1){
  Enumerate(function(){
    // QUD on premise interpretation is the conclusion
    var worldPosterior = marginalize(argumentStrength_pragmatic(premises, prior, speakerOptimality_E1), "state")

    var world = sample(worldPosterior)
    var trueSentences = filter(function(w){return w.truthValue}, world) // remove false sentences
    var conclusionIsTrue = conclusionTrue(conclusion, trueSentences)


    var utterances = conclusionIsTrue ? ['null', conclusion] : ['null']
    var utterance = uniformDraw(utterances)

    // could be a literal interpreter
    var l1 = conclusionToState_literal(utterance, prior)
    factor(l1.score([], world))
    return utterance
    // return conclusionIsTrue
  })
}

var speaker2_pL0_cL0 = function(premises, conclusion, prior, speakerOptimality_E1){
  Enumerate(function(){
    // QUD on premise interpretation is the conclusion
    var worldPosterior = premisesToState_literal(premises, prior)

    var world = sample(worldPosterior)
    var trueSentences = filter(function(w){return w.truthValue}, world) // remove false sentences
    var conclusionIsTrue = conclusionTrue(conclusion, trueSentences)


    var utterances = conclusionIsTrue ? ['null', conclusion] : ['null']
    var utterance = uniformDraw(utterances)

    // could be a literal interpreter
    var l1 = conclusionToState_literal(utterance, prior)
    factor(l1.score([], world))
    return utterance
    // return conclusionIsTrue
  })
}
