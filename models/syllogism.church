(define all-true (lambda (lst) (apply and lst)))
(define some-true (lambda (lst) (apply or lst)))

(define is-element? (lambda (el lst)
  (>= (position lst el) 0)))

(define (raise-to-power dist alph)
  (list (first dist) (map (lambda (x) (pow x alph)) (second dist))))

(define quantifiers (list 'all 'some 'none 'not-all))
(define sentence-forms (list 'A-B 'B-A 'B-C 'C-B 'A-C 'C-A))
(define property-order (list 'A 'B 'C))

(define syllogistic-sentences 
  (flatten
   (map (lambda (y) 
          (map (lambda (x) 
                 (string-append x '. y)) 
               sentence-forms))
        quantifiers)))

(define (forms fig)
  (case fig
        ((1) (list 'B-A 'C-B))
        ((2) (list 'A-B 'C-B))
        ((3) (list 'B-A 'B-C))
        ((4) (list 'A-B 'B-C))))

(define is-premise1? (lambda (sentence figure) 
  (equal? (first (regexp-split sentence '.)) (first (forms figure)))))

(define is-premise2? (lambda (sentence figure) 
  (equal? (first (regexp-split sentence '.)) (second (forms figure)))))

(define is-conclusion? (lambda (x) (and (equal? (first (regexp-split x '.)) 'C-A))))

(define premise-1s (lambda (figure)
  (filter 
    (lambda (sent) (is-premise1? sent figure))
    syllogistic-sentences)))

(define premise-2s (lambda (figure)
  (filter 
    (lambda (sent) (is-premise2? sent figure))
    syllogistic-sentences)))

(define sp 
  (map (lambda (x)
         (let ([lst
                (map (lambda (y) 
                       (map (lambda (z)
                              (list x (list y z)))
                            (premise-2s x)))
                     (premise-1s x))])
           (append (first lst) (second lst) (third lst) (fourth lst))))
       '(1 2 3 4)))

(define all-premises (append (first sp) (second sp) (third sp) (fourth sp)))

;; takes a string like 'A-B.all and returns (list 'A 'B 'all)
(define unpack-sentence (lambda (sentence)
  (let ([sentence-fragments (string-split sentence '.)])
    (flatten (list (string-split (first sentence-fragments) '-) (second sentence-fragments))))))


(define has-property? (lambda (x i ABC) (list-ref (ABC x) (position property-order i))))

(define state->sentences
  (lambda (situation) 
    (filter 
      (lambda (x) (list-ref situation (position syllogistic-sentences x)))
      syllogistic-sentences)))

(define (marginalize interpretation)
  (list
    (list 'C-A.all 'C-A.some 'C-A.none 'C-A.not-all)
    (list
     (sum (map (lambda (y) (second y)) (filter (lambda (x) (first (first x)))
                                               (zip (first interpretation) (second interpretation)))))
     (sum (map (lambda (y) (second y)) (filter (lambda (x) (second (first x)))
                                               (zip (first interpretation) (second interpretation)))))
     (sum (map (lambda (y) (second y)) (filter (lambda (x) (third (first x)))
                                               (zip (first interpretation) (second interpretation)))))
     (sum (map (lambda (y) (second y)) (filter (lambda (x) (fourth (first x)))
                                               (zip (first interpretation) (second interpretation))))))))

(define (get-indices needle haystack)
  (define (loop rest-of-haystack index)
    (if (null? rest-of-haystack) '()
      (let ((rest-of-indices (loop (rest rest-of-haystack) (+ index 1))))
        (if (equal? (first rest-of-haystack) needle)
          (pair index rest-of-indices)
          rest-of-indices))))
  (loop haystack 1))

(define (list-map lst)
  (if (all (map null? (map rest lst))) 
      lst
      (list (map first lst) (list-map (map rest lst)))))

(define (marginalize output)
  (let ([states (first output)])
    (map (lambda (sub-output) 
           (let* ([probs (second output)]
                  [unique-states (unique sub-output)]
                  [unique-state-indices 
                   (map 
                    (lambda (x) (list x (get-indices x sub-output))) 
                    unique-states)])

             (list (map first unique-state-indices)
                   (map 
                    (lambda (y) (sum (map 
                                      (lambda (x) (list-elt probs x)) 
                                      (second y)))) 
                    unique-state-indices))))
         (list-map states))))



; assume the situations constructed have at least one object with each of the properties
; (define existential-import (lambda (A B objects) 
;                              (and (some-true (map A objects)) (some-true (map B objects)))))

(define existential-import-m (lambda (ABC objects term1 term2)
                             (and (some-true (map (lambda (x) (has-property? x term1 ABC)) objects))
                                  (some-true (map (lambda (x) (has-property? x term2 ABC)) objects)))))

; (define plentiful-worlds (lambda (A B C objects)
;         (and (some-true (map A objects)) (some-true (map B objects)) (some-true (map C objects)))))

(define plentiful-worlds-m (lambda (ABC objects)
                             (and (some-true (map (lambda (x) (has-property? x 'A ABC)) objects))
                                  (some-true (map (lambda (x) (has-property? x 'B ABC)) objects))
                                  (some-true (map (lambda (x) (has-property? x 'C ABC)) objects)))))

; (define all (lambda (A B objects)
;               (if (existential-import A B objects)
;                   (all-true (map (lambda (x) (if (A x) (B x) true)) 
;                                  objects))
;                   false)))

; (define some (lambda (A B objects)
;                (if (existential-import A B objects)
;                    (some-true (map (lambda (x) (if (A x) (B x) false)) 
;                                    objects))
;                    false)))

; (define none (lambda (A B objects)
;                (if (existential-import A B objects)
;                    (all-true (map (lambda (x) (if (A x) (not (B x)) true)) 
;                                   objects))
;                    false)))

; (define not-all (lambda (A B objects)
;                   (if (existential-import A B objects)
;                       (some-true (map (lambda (x) (if (A x) (not (B x)) false)) 
;                                       objects))
;                       false)))

(define all-m (lambda (ABC objects property1 property2)
  (if (existential-import-m ABC objects property1 property2)
      (all-true (map 
        (lambda (x) (if (has-property? x property1 ABC) (has-property? x property2 ABC) true))
                     objects))
      false)))

(define some-m (lambda (ABC objects property1 property2)
  (if (existential-import-m ABC objects property1 property2)
      (some-true (map 
        (lambda (x) (if (has-property? x property1 ABC) (has-property? x property2 ABC) false))
                     objects))
      false)))

(define none-m (lambda (ABC objects property1 property2)
  (if (existential-import-m ABC objects property1 property2)
      (all-true (map 
        (lambda (x) (if (has-property? x property1 ABC) (not (has-property? x property2 ABC)) true))
                     objects))
      false)))

(define not-all-m (lambda (ABC objects property1 property2)
  (if (existential-import-m ABC objects property1 property2)
      (some-true (map 
        (lambda (x) (if (has-property? x property1 ABC) (not (has-property? x property2 ABC)) false))
                     objects))
      false)))




; pass strings, which then call functions of the same name

; (define (meaning word)
;   (case word
;         (('all) all)
;         (('some) some)
;         (('not-all) not-all)
;         (('none) none)))

(define (meaning word)
  (case word
        (('all) all-m)
        (('some) some-m)
        (('not-all) not-all-m)
        (('none) none-m)))

(define binom->multinom
  (mem
    (lambda (br)
      (enumeration-query
        (define A (mem (lambda (x) (flip br))))
          (define B (mem (lambda (x) (flip br))))
          (define C (mem (lambda (x) (flip br))))

          (list (A 'x) (B 'x) (C 'x))

          true))))


; (define equivalent-transform
;   (mem
;    (lambda (objects br)
;      (enumeration-query
;       ; properties map objects to truth-values i.e. whether or not the object has the property
;       ; together with the list of objects, these represent situations over which reasoning occurs
;       (define A (mem (lambda (x) (flip br))))
;       (define B (mem (lambda (x) (flip br))))
;       (define C (mem (lambda (x) (flip br))))
;       (define (property p)
;         (case p
;               (('A) A)
;               (('B) B)
;               (('C) C)))
      
;       (map 
;         (lambda (sentence) 
;           (let ([s (unpack-sentence sentence)]) 
;           ((meaning (third s)) (property (first s)) (property (second s)) objects))) 
;         syllogistic-sentences)


;      ;true
;      (plentiful-worlds A B C objects)))))




(define multinomial-properties 
  '((#f #f #f) (#f #f #t) (#f #t #f) (#f #t #t) 
    (#t #f #f) (#t #f #t) (#t #t #f) (#t #t #t)))

(define equivalent-transform-m
  (mem
   (lambda (objects background-prior)
     (enumeration-query
;      (define ABC (mem (lambda (x) (apply multinomial background-prior))))
      (define ABC (mem (lambda (x) (multinomial multinomial-properties background-prior))))
        
        (map 
          (lambda (sentence) 
            (let ([s (unpack-sentence sentence)])
            ((meaning (third s)) ABC objects (first s) (second s))))
          syllogistic-sentences)

     ;true
     (plentiful-worlds-m ABC objects)))))


;; posterior median for lightbulbs

; alpha 3
;
; 1      111 0.16787938
; 2      110 0.12412901
; 3      101 0.12365418
; 4      011 0.05193817
; 5      100 0.11577700
; 6      010 0.02406771
; 7      001 0.09753311
; 8      000 0.16239389


(define lightbulb-beta '(0.16239389 0.09753311 0.02406771 0.05193817 
                         0.11577700 0.12365418 0.12412901 0.16787938))

(define lightbulb-alpha 3)
(define lightbulb-hyperparams (map (lambda (x) (* lightbulb-alpha x)) lightbulb-beta))


(define lightbulb-means '(0.225972233 0.08556292 0.033416427 0.031271622
                          0.085948385 0.115978747 0.110020792 0.311828874))

;(define equivalent-worlds (equivalent-transform-m objs (binom->multinom 0.25)))
;(define hyper-equivalent-transform-m 
;  (lambda (objects hyperpiors) (equivalent-transform-m objects (dirichlet hyperpiors))))

; (define hyper-equivalent-transform-m 
;   (lambda (objects hyperpiors) 
;     (let ([bp (dirichlet hyperpiors)])
;       (equivalent-transform-m objects bp))))

(define hyper-equivalent-transform-m 
  (lambda (objects hyperpiors) 
    (let ([bp (dirichlet hyperpiors)])
      (list (equivalent-transform-m objects bp) bp))))

; (define state-prior-prior 
;   (repeat 3 (lambda () (hyper-equivalent-transform-m objs lightbulb-hyperparams))))

; cognitive model parameters
(define objs (list 'o1 'o2 'o3 'o4 'o5))
(define alpha 3)

(define reasoner1
  (mem (lambda  (premises figure)
    (enumeration-query
       ;(define equivalent-worlds-w-tags (uniform-draw state-prior-prior))

       ;(define equivalent-worlds (first equivalent-worlds-w-tags))
       ;(define equivalent-worlds (uniform-draw state-prior-prior))
       (define equivalent-worlds (equivalent-transform-m objs lightbulb-hyperparams))
       ;(define equivalent-worlds (equivalent-transform-m objs lightbulb-means))

       (define state (apply multinomial equivalent-worlds))
       
       (define true-conclusions (filter is-conclusion? (state->sentences state)))
       (define which-conclusions (list (is-element? 'C-A.all true-conclusions)
                                        (is-element? 'C-A.some true-conclusions)
                                        (is-element? 'C-A.none true-conclusions)
                                        (is-element? 'C-A.not-all true-conclusions)))
       (define conclusion (uniform-draw true-conclusions))

       ;(list conclusion (second equivalent-worlds-w-tags))
       conclusion
       ;true-conclusions
       ;which-conclusions

       (equal? premises (apply multinomial (raise-to-power (experimenter1 conclusion figure equivalent-worlds) alpha)))
       ;(equal? premises (apply multinomial (raise-to-power (experimenter1 conclusion figure) alpha)))
       ;(equal? premises (apply multinomial (raise-to-power (experimenter1 true-conclusions figure) alpha)))
       ;(equal? premises (apply multinomial (raise-to-power (experimenter1 which-conclusions figure) alpha)))
       ))))

(define experimenter1
  (mem (lambda (QUDval figure equivalent-worlds)
;  (mem (lambda (QUDval figure)   
     (enumeration-query
      (define premises (list (uniform-draw (premise-1s figure)) (uniform-draw (premise-2s figure))))
      
      premises
      
      (equal? 
        QUDval 
        ;(apply multinomial (marginalize (reasoner0 premises)) ))))))
        (apply multinomial (reasoner0 premises equivalent-worlds)))))))

(define reasoner0
   (mem 
    (lambda  (premises equivalent-worlds)
;    (lambda  (premises)
      (enumeration-query
;       (define equivalent-worlds (uniform-draw state-prior-prior))
       (define state (apply multinomial equivalent-worlds))
       (define true-sentences (state->sentences state))
       (define conclusion (uniform-draw (filter is-conclusion? true-sentences)))
       (define which-conclusions (list 
            (is-element? 'C-A.all true-sentences)
            (is-element? 'C-A.some true-sentences)
            (is-element? 'C-A.none true-sentences)
            (is-element? 'C-A.not-all true-sentences)))

       conclusion
;       (filter is-conclusion? true-sentences)
;        which-conclusions

       (and 
          (is-element? (first premises) true-sentences)
          (is-element? (second premises) true-sentences))))))


;(second (hyper-equivalent-transform-m objs lightbulb-beta))

;(define results (map (lambda (x) (list x (reasoner1 (second x) (first x)))) all-premises))

;(write-csv results 'syllmodel_lightbulb_hyperprior100_n5_alpha3.csv)

;(reasoner0 (list 'B-A.all 'C-B.all))
;(experimenter1 'C-A.all 1)
(reasoner1 (list 'B-A.none 'C-B.all) 1)
;(hyper-equivalent-transform-m objs)
