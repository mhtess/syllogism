(define quantifiers (list 'all 'some 'none 'not-all))
(define sentence-forms (list 'A-B 'B-A 'B-C 'C-B 'A-C 'C-A))

(define is-element? (lambda (el lst)
  (>= (position lst el) 0)))

(define syllogistic-sentences 
  (flatten
   (map (lambda (y) 
          (map (lambda (x) 
                 (string-append x '. y)) 
               sentence-forms))
        quantifiers)))

(define unpack-sentence (lambda (sentence)
  (let ([sentence-fragments (string-split sentence '.)])
    (flatten (list (string-split (first sentence-fragments) '-) (second sentence-fragments))))))

(define all-true (lambda (lst) (apply and lst)))
(define some-true (lambda (lst) (apply or lst)))

; assume the situations constructed have at least one object with each of the properties
(define existential-import (lambda (A B objects) 
                             (and (some-true (map A objects)) (some-true (map B objects)))))

(define plentiful-worlds (lambda (A B C objects)
        (and (some-true (map A objects)) (some-true (map B objects)) (some-true (map C objects)))))

(define all (lambda (A B objects)
              (if (existential-import A B objects)
                  (all-true (map (lambda (x) (if (A x) (B x) true)) 
                                 objects))
                  false)))

(define some (lambda (A B objects)
               (if (existential-import A B objects)
                   (some-true (map (lambda (x) (if (A x) (B x) false)) 
                                   objects))
                   false)))

(define none (lambda (A B objects)
               (if (existential-import A B objects)
                   (all-true (map (lambda (x) (if (A x) (not (B x)) true)) 
                                  objects))
                   false)))

(define not-all (lambda (A B objects)
                  (if (existential-import A B objects)
                      (some-true (map (lambda (x) (if (A x) (not (B x)) false)) 
                                      objects))
                      false)))

(define (raise-to-power dist alph)
  (list (first dist) (map (lambda (x) (pow x alph)) (second dist))))

; pass strings, which then call functions of the same name
(define (meaning word)
  (case word
        (('all) all)
        (('some) some)
        (('not-all) not-all)
        (('none) none)))

(define (forms fig)
  (case fig
        ((1) (list 'B-A 'C-B))
        ((2) (list 'A-B 'C-B))
        ((3) (list 'B-A 'B-C))
        ((4) (list 'A-B 'B-C))))

(define is-premise1? (lambda (sentence figure) 
  (equal? (first (regexp-split sentence '.)) (first (forms figure)))))

(define is-premise2? (lambda (sentence figure) 
  (equal? (first (regexp-split sentence '.)) (second (forms figure)))))

(define premise-1s (lambda (figure)
  (filter 
    (lambda (sent) (is-premise1? sent figure))
    syllogistic-sentences)))

(define premise-2s (lambda (figure)
  (filter 
    (lambda (sent) (is-premise2? sent figure))
    syllogistic-sentences)))


; the reasoner has uninformative prior beliefs about what the conclusion should be
(define (conclusion-prior) (uniform-draw (list 'all 'some 'not-all 'none)))
; rhe reasoner has uninformative prior beliefs about what arguments the experimenter could give
(define (premise-prior) (uniform-draw (list 'all 'some 'not-all 'none)))

; parameter 1: the reasoner's prior beliefs about the rarity of properties
(define br 0.25)

(define equivalent-transform
  (mem
   (lambda (objects)
     (enumeration-query
      ; properties map objects to truth-values i.e. whether or not the object has the property
      ; together with the list of objects, these represent situations over which reasoning occurs
      (define A (mem (lambda (x) (flip br))))
      (define B (mem (lambda (x) (flip br))))
      (define C (mem (lambda (x) (flip br))))
      (define (property p)
        (case p
              (('A) A)
              (('B) B)
              (('C) C)))
      
      (map 
        (lambda (sentence) (let ([s (unpack-sentence sentence)]) 
          ((meaning (third s)) (property (first s)) (property (second s)) objects))) 
        syllogistic-sentences)


     ;true
     (plentiful-worlds A B C objects)))))


; parameter 2: number of objects in the situation the reasoner imagines
(define objs (list 'o1 'o2 'o3 'o4))

(define equivalent-worlds (equivalent-transform objs))

(define state->sentences
  (lambda (situation) 
    (filter 
      (lambda (x) (list-ref situation (position syllogistic-sentences x)))
      syllogistic-sentences)))


(define is-conclusion? (lambda (x) (and (equal? (first (regexp-split x '.)) 'C-A))))

(define alpha 3)

(define reasoner1
  (mem (lambda  (premises figure)
    (enumeration-query
       (define state (apply multinomial equivalent-worlds))
       (define true-sentences (state->sentences state))
       (define conclusion (uniform-draw (filter is-conclusion? true-sentences)))

       conclusion

       (equal? premises (apply multinomial (experimenter1 conclusion figure)))))))

(define experimenter1
  (mem (lambda (conclusion figure)
     (enumeration-query
      (define premises (list (uniform-draw (premise-1s figure)) (uniform-draw (premise-2s figure))))
      
      premises
      
      (equal? conclusion (apply multinomial (raise-to-power (reasoner0 premises) alpha)))))))

(define reasoner0
   (mem 
    (lambda  (premises)
      (enumeration-query
       (define state (apply multinomial equivalent-worlds))
       (define true-sentences (state->sentences state))
       (define conclusion (uniform-draw (filter is-conclusion? true-sentences)))

       conclusion
      
       (and 
          (is-element? (first premises) true-sentences)
          (is-element? (second premises) true-sentences))))))

;(reasoner0 (list 'B-A.all 'C-B.all))
;(experimenter1 'C-A.all 1)
(reasoner1 (list 'B-A.all 'C-B.all) 1)
