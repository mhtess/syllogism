;;; priors on priors four ways
;; pop1 - dirichlet; alpha & beta from tFBT on prior elicitation
;; pop2 - crazy-world? (multinomial (tFBT-p.e. betas) (dirichlet '(1 1 1 ...)))
;; pop3 - dirichlet; betas from tFBT p.e. but exponential over alpha
;; jsp (just some priors) - (multinomial (tFBT-p.e. betas)) [like pop2 but minus crazy-world?]




(define args
  (regexp_split argstring ","))
; cognitive model parameters

(define n_obj-string (first args))
(define alpha-str (second args))
(define domain (third args))

(define alpha (string->number alpha-str))
(define objs (repeat (string->number n_obj-string) gensym))

;;; read in empirical prior data
(define prior-path '/Users/mht/Documents/research/syllogism/analysis/)
(define domain-priors (read-csv (string-append prior-path 'max_posterior_priors domain '_mh1000k.csv)))

(define numstates->boolstates (lambda (lst)
  (map number->boolean (map string->number (string-split lst "")))))

(define all-true (lambda (lst) (apply and lst)))
(define some-true (lambda (lst) (apply or lst)))

(define is-element? (lambda (el lst)
  (>= (position lst el) 0)))

(define (raise-to-power dist alph)
  (list (first dist) (map (lambda (x) (pow x alph)) (second dist))))

(define quantifiers (list 'all 'some 'none 'not-all))
(define sentence-forms (list 'A-B 'B-A 'B-C 'C-B 'A-C 'C-A))
(define property-order (list 'A 'B 'C))

(define output-order (list 'C-A.all 'C-A.none 'C-A.some 'C-A.not-all))


(define syllogistic-sentences 
  (flatten
   (map (lambda (y) 
          (map (lambda (x) 
                 (string-append x '. y)) 
               sentence-forms))
        quantifiers)))

(define (forms fig)
  (case fig
        ((1) (list 'B-A 'C-B))
        ((2) (list 'A-B 'C-B))
        ((3) (list 'B-A 'B-C))
        ((4) (list 'A-B 'B-C))))

(define (scholastic-dictionary quantifier)
  (case quantifier
    (('all) 'A)
    (('none) 'E)
    (('some) 'I)
    (('not-all) 'O)))

(define is-premise1? (lambda (sentence figure) 
  (equal? (first (regexp-split sentence '.)) (first (forms figure)))))

(define is-premise2? (lambda (sentence figure) 
  (equal? (first (regexp-split sentence '.)) (second (forms figure)))))

(define is-conclusion? (lambda (x) (and (equal? (first (regexp-split x '.)) 'C-A))))

(define premise-1s (lambda (figure)
  (filter 
    (lambda (sent) (is-premise1? sent figure))
    syllogistic-sentences)))

(define premise-2s (lambda (figure)
  (filter 
    (lambda (sent) (is-premise2? sent figure))
    syllogistic-sentences)))

(define sp 
  (map (lambda (x)
         (let ([lst
                (map (lambda (y) 
                       (map (lambda (z)
                              (list x (list y z)))
                            (premise-2s x)))
                     (premise-1s x))])
           (append (first lst) (second lst) (third lst) (fourth lst))))
       '(1 2 3 4)))

(define all-premises (append (first sp) (second sp) (third sp) (fourth sp)))

;; takes a string like 'A-B.all and returns (list 'A 'B 'all)
(define unpack-sentence (lambda (sentence)
  (let ([sentence-fragments (string-split sentence '.)])
    (flatten (list (string-split (first sentence-fragments) '-) (second sentence-fragments))))))


(define has-property? (lambda (x i ABC) (list-ref (ABC x) (position property-order i))))

(define state->sentences
  (lambda (situation) 
    (filter 
      (lambda (x) (list-ref situation (position syllogistic-sentences x)))
      syllogistic-sentences)))

(define (marginalize interpretation)
  (list
    (list 'C-A.all 'C-A.some 'C-A.none 'C-A.not-all)
    (list
     (sum (map (lambda (y) (second y)) (filter (lambda (x) (first (first x)))
                                               (zip (first interpretation) (second interpretation)))))
     (sum (map (lambda (y) (second y)) (filter (lambda (x) (second (first x)))
                                               (zip (first interpretation) (second interpretation)))))
     (sum (map (lambda (y) (second y)) (filter (lambda (x) (third (first x)))
                                               (zip (first interpretation) (second interpretation)))))
     (sum (map (lambda (y) (second y)) (filter (lambda (x) (fourth (first x)))
                                               (zip (first interpretation) (second interpretation))))))))

(define (get-indices needle haystack)
  (define (loop rest-of-haystack index)
    (if (null? rest-of-haystack) '()
      (let ((rest-of-indices (loop (rest rest-of-haystack) (+ index 1))))
        (if (equal? (first rest-of-haystack) needle)
          (pair index rest-of-indices)
          rest-of-indices))))
  (loop haystack 1))

(define (list-map lst)
  (if (all (map null? (map rest lst))) 
      lst
      (list (map first lst) (list-map (map rest lst)))))

(define (marginalize output)
  (let ([states (first output)])
    (map (lambda (sub-output) 
           (let* ([probs (second output)]
                  [unique-states (unique sub-output)]
                  [unique-state-indices 
                   (map 
                    (lambda (x) (list x (get-indices x sub-output))) 
                    unique-states)])

             (list (map first unique-state-indices)
                   (map 
                    (lambda (y) (sum (map 
                                      (lambda (x) (list-elt probs x)) 
                                      (second y)))) 
                    unique-state-indices))))
         (list-map states))))


(define (make-results results)
  (map 
   (lambda (x) (let ([where-x (position (first results) x)])
                 (if (>= where-x 0)
                     (list-ref (second results) where-x)
                     0)))
   output-order))

(define (sylly-codes full-premises)
  (let* ([prems (second full-premises)]
         [figure (number->string (first full-premises))]
         [code-list (map (lambda (prem) (scholastic-dictionary (second (string-split prem '.)))) prems)])
    (string-append (first code-list) (second code-list) figure)))


; assume the situations constructed have at least one object with each of the properties
; (define existential-import (lambda (A B objects) 
;                              (and (some-true (map A objects)) (some-true (map B objects)))))

(define existential-import-m (lambda (ABC objects term1 term2)
                             (and (some-true (map (lambda (x) (has-property? x term1 ABC)) objects))
                                  (some-true (map (lambda (x) (has-property? x term2 ABC)) objects)))))

; (define plentiful-worlds (lambda (A B C objects)
;         (and (some-true (map A objects)) (some-true (map B objects)) (some-true (map C objects)))))

(define plentiful-worlds-m (lambda (ABC objects)
                             (and (some-true (map (lambda (x) (has-property? x 'A ABC)) objects))
                                  (some-true (map (lambda (x) (has-property? x 'B ABC)) objects))
                                  (some-true (map (lambda (x) (has-property? x 'C ABC)) objects)))))

; (define all (lambda (A B objects)
;               (if (existential-import A B objects)
;                   (all-true (map (lambda (x) (if (A x) (B x) true)) 
;                                  objects))
;                   false)))

; (define some (lambda (A B objects)
;                (if (existential-import A B objects)
;                    (some-true (map (lambda (x) (if (A x) (B x) false)) 
;                                    objects))
;                    false)))

; (define none (lambda (A B objects)
;                (if (existential-import A B objects)
;                    (all-true (map (lambda (x) (if (A x) (not (B x)) true)) 
;                                   objects))
;                    false)))

; (define not-all (lambda (A B objects)
;                   (if (existential-import A B objects)
;                       (some-true (map (lambda (x) (if (A x) (not (B x)) false)) 
;                                       objects))
;                       false)))

(define all-m (lambda (ABC objects property1 property2)
  (if (existential-import-m ABC objects property1 property2)
      (all-true (map 
        (lambda (x) (if (has-property? x property1 ABC) (has-property? x property2 ABC) true))
                     objects))
      false)))

(define some-m (lambda (ABC objects property1 property2)
  (if (existential-import-m ABC objects property1 property2)
      (some-true (map 
        (lambda (x) (if (has-property? x property1 ABC) (has-property? x property2 ABC) false))
                     objects))
      false)))

(define none-m (lambda (ABC objects property1 property2)
  (if (existential-import-m ABC objects property1 property2)
      (all-true (map 
        (lambda (x) (if (has-property? x property1 ABC) (not (has-property? x property2 ABC)) true))
                     objects))
      false)))

(define not-all-m (lambda (ABC objects property1 property2)
  (if (existential-import-m ABC objects property1 property2)
      (some-true (map 
        (lambda (x) (if (has-property? x property1 ABC) (not (has-property? x property2 ABC)) false))
                     objects))
      false)))


; pass strings, which then call functions of the same name

; (define (meaning word)
;   (case word
;         (('all) all)
;         (('some) some)
;         (('not-all) not-all)
;         (('none) none)))

(define (meaning word)
  (case word
        (('all) all-m)
        (('some) some-m)
        (('not-all) not-all-m)
        (('none) none-m)))

(define binom->multinom
  (mem
    (lambda (br)
      (enumeration-query
        (define A (mem (lambda (x) (flip br))))
          (define B (mem (lambda (x) (flip br))))
          (define C (mem (lambda (x) (flip br))))

          (list (A 'x) (B 'x) (C 'x))

          true))))

; (define equivalent-transform
;   (mem
;    (lambda (objects br)
;      (enumeration-query
;       ; properties map objects to truth-values i.e. whether or not the object has the property
;       ; together with the list of objects, these represent situations over which reasoning occurs
;       (define A (mem (lambda (x) (flip br))))
;       (define B (mem (lambda (x) (flip br))))
;       (define C (mem (lambda (x) (flip br))))
;       (define (property p)
;         (case p
;               (('A) A)
;               (('B) B)
;               (('C) C)))
      
;       (map 
;         (lambda (sentence) 
;           (let ([s (unpack-sentence sentence)]) 
;           ((meaning (third s)) (property (first s)) (property (second s)) objects))) 
;         syllogistic-sentences)


;      ;true
;      (plentiful-worlds A B C objects)))))


;; note to MH: I could speed this up by incorporating "plentiful worlds" into sampling

(define equivalent-transform-m
  (mem
   (lambda (objects background-prior)
     (enumeration-query
;      (define ABC (mem (lambda (x) (apply multinomial background-prior))))
      (define ABC (mem (lambda (x) (multinomial multinomial-properties background-prior))))
        
        (map 
          (lambda (sentence) 
            (let ([s (unpack-sentence sentence)])
            ((meaning (third s)) ABC objects (first s) (second s))))
          syllogistic-sentences)

     ;true
     (plentiful-worlds-m ABC objects)))))


;; if using i.i.d. prior (and hence, using binom->multinom), use the following ordering
; (define multinomial-properties 
;   '((#f #f #f) (#f #f #t) (#f #t #f) (#f #t #t) 
;     (#t #f #f) (#t #f #t) (#t #t #f) (#t #t #t)))

;; otherwise, read it off the empirical prior csv (columns 3-end)
(define multinomial-properties (map numstates->boolstates (cdr (cdr (second domain-priors)))))

;; fourth row is expected value from posterior
(define domain-beta (cdr (cdr (fourth domain-priors))))
(define domain-alpha (first (cdr (fourth domain-priors))))

(define domain-hyperparams (map (lambda (x) (* domain-alpha x)) domain-beta))

; (define lightbulb-means '(0.225972233 0.08556292 0.033416427 0.031271622
;                           0.085948385 0.115978747 0.110020792 0.311828874))



;(define equivalent-worlds (equivalent-transform-m objs (binom->multinom 0.25)))
;(define hyper-equivalent-transform-m 
;  (lambda (objects hyperpiors) (equivalent-transform-m objects (dirichlet hyperpiors))))

; (define hyper-equivalent-transform-m 
;   (lambda (objects hyperpiors) 
;     (let ([bp (dirichlet hyperpiors)])
;       (equivalent-transform-m objects bp))))

(define hyper-equivalent-transform-m 
  (lambda (objects hyperpiors) 
    (let ([bp (dirichlet hyperpiors)])
      (list (equivalent-transform-m objects bp) bp))))

; (define state-prior-prior 
;   (repeat 3 (lambda () (hyper-equivalent-transform-m objs lightbulb-hyperparams))))



(define reasoner1
  (mem (lambda  (premises figure)
    (enumeration-query
       ;(define equivalent-worlds-w-tags (uniform-draw state-prior-prior))

       ;(define equivalent-worlds (first equivalent-worlds-w-tags))
       ;(define equivalent-worlds (uniform-draw state-prior-prior))
       (define equivalent-worlds (equivalent-transform-m objs lightbulb-hyperparams))
       ;(define equivalent-worlds (equivalent-transform-m objs lightbulb-means))

       (define state (apply multinomial equivalent-worlds))
       
       (define true-conclusions (filter is-conclusion? (state->sentences state)))
       (define which-conclusions (list (is-element? 'C-A.all true-conclusions)
                                        (is-element? 'C-A.some true-conclusions)
                                        (is-element? 'C-A.none true-conclusions)
                                        (is-element? 'C-A.not-all true-conclusions)))
       (define conclusion (uniform-draw true-conclusions))

       ;(list conclusion (second equivalent-worlds-w-tags))
       conclusion
       ;true-conclusions
       ;which-conclusions

       (equal? premises (apply multinomial (raise-to-power (experimenter1 conclusion figure equivalent-worlds) alpha)))
       ;(equal? premises (apply multinomial (raise-to-power (experimenter1 conclusion figure) alpha)))
       ;(equal? premises (apply multinomial (raise-to-power (experimenter1 true-conclusions figure) alpha)))
       ;(equal? premises (apply multinomial (raise-to-power (experimenter1 which-conclusions figure) alpha)))
       ))))

(define experimenter1
  (mem (lambda (QUDval figure equivalent-worlds)
;  (mem (lambda (QUDval figure)   
     (enumeration-query
      (define premises (list (uniform-draw (premise-1s figure)) (uniform-draw (premise-2s figure))))
      
      premises
      
      (equal? 
        QUDval 
        ;(apply multinomial (marginalize (reasoner0 premises)) ))))))
        (apply multinomial (reasoner0 premises equivalent-worlds)))))))

(define reasoner0
   (mem 
    (lambda  (premises equivalent-worlds)
;    (lambda  (premises)
      (enumeration-query
;       (define equivalent-worlds (uniform-draw state-prior-prior))
       (define state (apply multinomial equivalent-worlds))
       (define true-sentences (state->sentences state))
       (define conclusion (uniform-draw (filter is-conclusion? true-sentences)))
       (define which-conclusions (list 
            (is-element? 'C-A.all true-sentences)
            (is-element? 'C-A.some true-sentences)
            (is-element? 'C-A.none true-sentences)
            (is-element? 'C-A.not-all true-sentences)))

       conclusion
;       (filter is-conclusion? true-sentences)
;        which-conclusions

       (and 
          (is-element? (first premises) true-sentences)
          (is-element? (second premises) true-sentences))))))


(define results (map 
  (lambda (x) 
    (flatten (list 
      (sylly-codes x) 
      (make-results (reasoner1 (second x) (first x))))))
  all-premises))

(write-csv results (string-append 'syllmodel_ domain '_n n_obj-string '_alpha alpha-str '.csv))


