(define all-true (lambda (lst) (apply and lst)))
(define some-true (lambda (lst) (apply or lst)))

(define is-element? (lambda (el lst)
  (>= (position lst el) 0)))

(define (raise-to-power dist alph)
  (list (first dist) (map (lambda (x) (pow x alph)) (second dist))))

(define quantifiers (list 'all 'some 'none 'not-all))
(define sentence-forms (list 'A-B 'B-A 'B-C 'C-B 'A-C 'C-A))
(define property-order (list 'A 'B 'C))

(define syllogistic-sentences 
  (flatten
   (map (lambda (y) 
          (map (lambda (x) 
                 (string-append x '. y)) 
               sentence-forms))
        quantifiers)))

(define (forms fig)
  (case fig
        ((1) (list 'B-A 'C-B))
        ((2) (list 'A-B 'C-B))
        ((3) (list 'B-A 'B-C))
        ((4) (list 'A-B 'B-C))))

(define is-premise1? (lambda (sentence figure) 
  (equal? (first (regexp-split sentence '.)) (first (forms figure)))))

(define is-premise2? (lambda (sentence figure) 
  (equal? (first (regexp-split sentence '.)) (second (forms figure)))))

(define is-conclusion? (lambda (x) (and (equal? (first (regexp-split x '.)) 'C-A))))

(define premise-1s (lambda (figure)
  (filter 
    (lambda (sent) (is-premise1? sent figure))
    syllogistic-sentences)))

(define premise-2s (lambda (figure)
  (filter 
    (lambda (sent) (is-premise2? sent figure))
    syllogistic-sentences)))

;; takes a string like 'A-B.all and returns (list 'A 'B 'all)
(define unpack-sentence (lambda (sentence)
  (let ([sentence-fragments (string-split sentence '.)])
    (flatten (list (string-split (first sentence-fragments) '-) (second sentence-fragments))))))


(define has-property? (lambda (x i ABC) (list-ref (ABC x) (position property-order i))))


; assume the situations constructed have at least one object with each of the properties
; (define existential-import (lambda (A B objects) 
;                              (and (some-true (map A objects)) (some-true (map B objects)))))

(define existential-import-m (lambda (ABC objects term1 term2)
                             (and (some-true (map (lambda (x) (has-property? x term1 ABC)) objects))
                                  (some-true (map (lambda (x) (has-property? x term2 ABC)) objects)))))

; (define plentiful-worlds (lambda (A B C objects)
;         (and (some-true (map A objects)) (some-true (map B objects)) (some-true (map C objects)))))

(define plentiful-worlds-m (lambda (ABC objects)
                             (and (some-true (map (lambda (x) (has-property? x 'A ABC)) objects))
                                  (some-true (map (lambda (x) (has-property? x 'B ABC)) objects))
                                  (some-true (map (lambda (x) (has-property? x 'C ABC)) objects)))))

; (define all (lambda (A B objects)
;               (if (existential-import A B objects)
;                   (all-true (map (lambda (x) (if (A x) (B x) true)) 
;                                  objects))
;                   false)))

; (define some (lambda (A B objects)
;                (if (existential-import A B objects)
;                    (some-true (map (lambda (x) (if (A x) (B x) false)) 
;                                    objects))
;                    false)))

; (define none (lambda (A B objects)
;                (if (existential-import A B objects)
;                    (all-true (map (lambda (x) (if (A x) (not (B x)) true)) 
;                                   objects))
;                    false)))

; (define not-all (lambda (A B objects)
;                   (if (existential-import A B objects)
;                       (some-true (map (lambda (x) (if (A x) (not (B x)) false)) 
;                                       objects))
;                       false)))

(define all-m (lambda (ABC objects property1 property2)
  (if (existential-import-m ABC objects property1 property2)
      (all-true (map 
        (lambda (x) (if (has-property? x property1 ABC) (has-property? x property2 ABC) true))
                     objects))
      false)))

(define some-m (lambda (ABC objects property1 property2)
  (if (existential-import-m ABC objects property1 property2)
      (some-true (map 
        (lambda (x) (if (has-property? x property1 ABC) (has-property? x property2 ABC) false))
                     objects))
      false)))

(define none-m (lambda (ABC objects property1 property2)
  (if (existential-import-m ABC objects property1 property2)
      (all-true (map 
        (lambda (x) (if (has-property? x property1 ABC) (not (has-property? x property2 ABC)) true))
                     objects))
      false)))

(define not-all-m (lambda (ABC objects property1 property2)
  (if (existential-import-m ABC objects property1 property2)
      (some-true (map 
        (lambda (x) (if (has-property? x property1 ABC) (not (has-property? x property2 ABC)) false))
                     objects))
      false)))




; pass strings, which then call functions of the same name

; (define (meaning word)
;   (case word
;         (('all) all)
;         (('some) some)
;         (('not-all) not-all)
;         (('none) none)))

(define (meaning word)
  (case word
        (('all) all-m)
        (('some) some-m)
        (('not-all) not-all-m)
        (('none) none-m)))



; parameter 1: the reasoner's prior beliefs about the rarity of properties
(define br 0.25)

; (define equivalent-transform
;   (mem
;    (lambda (objects)
;      (enumeration-query
;       ; properties map objects to truth-values i.e. whether or not the object has the property
;       ; together with the list of objects, these represent situations over which reasoning occurs
;       (define A (mem (lambda (x) (flip br))))
;       (define B (mem (lambda (x) (flip br))))
;       (define C (mem (lambda (x) (flip br))))
;       (define (property p)
;         (case p
;               (('A) A)
;               (('B) B)
;               (('C) C)))
      
;       (map 
;         (lambda (sentence) 
;           (let ([s (unpack-sentence sentence)]) 
;           ((meaning (third s)) (property (first s)) (property (second s)) objects))) 
;         syllogistic-sentences)


;      ;true
;      (plentiful-worlds A B C objects)))))


(define binom->multinom
  (mem
    (lambda (br)
      (enumeration-query
        (define A (mem (lambda (x) (flip br))))
          (define B (mem (lambda (x) (flip br))))
          (define C (mem (lambda (x) (flip br))))

          (list (A 'x) (B 'x) (C 'x))

          true))))

(define background-prior (binom->multinom 0.25))

(define equivalent-transform-m
  (mem
   (lambda (objects)
     (enumeration-query
      (define ABC (mem (lambda (x) (apply multinomial background-prior))))
      
      (map 
        (lambda (sentence) 
          (let ([s (unpack-sentence sentence)]) 
          ((meaning (third s)) ABC objects (first s) (second s)))) 
        syllogistic-sentences)


     ;true
     (plentiful-worlds-m ABC objects)))))




; parameter 2: number of objects in the situation the reasoner imagines
(define objs (list 'o1 'o2 'o3))

(define equivalent-worlds (equivalent-transform-m objs))

(define state->sentences
  (lambda (situation) 
    (filter 
      (lambda (x) (list-ref situation (position syllogistic-sentences x)))
      syllogistic-sentences)))



(define alpha 3)

(define (marginalize interpretation)
  (list
    (list 'C-A.all 'C-A.some 'C-A.none 'C-A.not-all)
    (list
     (sum (map (lambda (y) (second y)) (filter (lambda (x) (first (first x)))
                                               (zip (first interpretation) (second interpretation)))))
     (sum (map (lambda (y) (second y)) (filter (lambda (x) (second (first x)))
                                               (zip (first interpretation) (second interpretation)))))
     (sum (map (lambda (y) (second y)) (filter (lambda (x) (third (first x)))
                                               (zip (first interpretation) (second interpretation)))))
     (sum (map (lambda (y) (second y)) (filter (lambda (x) (fourth (first x)))
                                               (zip (first interpretation) (second interpretation))))))))

(define reasoner1
  (mem (lambda  (premises figure)
    (enumeration-query
       (define state (apply multinomial equivalent-worlds))
       (define true-conclusions (filter is-conclusion? (state->sentences state)))
       (define conclusion (uniform-draw true-conclusions))
       (define which-conclusions (list 
            (is-element? 'C-A.all true-conclusions)
            (is-element? 'C-A.some true-conclusions)
            (is-element? 'C-A.none true-conclusions)
            (is-element? 'C-A.not-all true-conclusions)))

       conclusion
       ;true-conclusions
       ;which-conclusions

       (equal? premises (apply multinomial (experimenter1 conclusion figure)))
       ;(equal? premises (apply multinomial (experimenter1 true-conclusions figure)))
       ;(equal? premises (apply multinomial (experimenter1 which-conclusions figure)))
       ))))

(define experimenter1
  (mem (lambda (QUDval figure)
     (enumeration-query
      (define premises (list (uniform-draw (premise-1s figure)) (uniform-draw (premise-2s figure))))
      
      premises
      
      (equal? 
        QUDval 
        ;(apply multinomial (raise-to-power (marginalize (reasoner0 premises)) alpha)))))))
        (apply multinomial (raise-to-power (reasoner0 premises) alpha)))))))

(define reasoner0
   (mem 
    (lambda  (premises)
      (enumeration-query
       (define state (apply multinomial equivalent-worlds))
       (define true-sentences (state->sentences state))
       (define conclusion (uniform-draw (filter is-conclusion? true-sentences)))
       (define which-conclusions (list 
            (is-element? 'C-A.all true-sentences)
            (is-element? 'C-A.some true-sentences)
            (is-element? 'C-A.none true-sentences)
            (is-element? 'C-A.not-all true-sentences)))

       conclusion
;       (filter is-conclusion? true-sentences)
;        which-conclusions

       (and 
          (is-element? (first premises) true-sentences)
          (is-element? (second premises) true-sentences))))))

;(reasoner0 (list 'B-A.all 'C-B.all))
;(experimenter1 'C-A.all 1)
(reasoner1 (list 'B-A.all 'C-B.all) 1)

