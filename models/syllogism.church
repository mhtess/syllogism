(define all-true (lambda (lst) (apply and lst)))
(define some-true (lambda (lst) (apply or lst)))

(define is-element? (lambda (el lst)
  (>= (position lst el) 0)))

(define (raise-to-power dist alph)
  (list (first dist) (map (lambda (x) (pow x alph)) (second dist))))

(define quantifiers (list 'all 'some 'none 'not-all))
(define sentence-forms (list 'A-B 'B-A 'B-C 'C-B 'A-C 'C-A))
(define property-order (list 'A 'B 'C))

(define syllogistic-sentences 
  (flatten
   (map (lambda (y) 
          (map (lambda (x) 
                 (string-append x '. y)) 
               sentence-forms))
        quantifiers)))

(define (forms fig)
  (case fig
        ((1) (list 'B-A 'C-B))
        ((2) (list 'A-B 'C-B))
        ((3) (list 'B-A 'B-C))
        ((4) (list 'A-B 'B-C))))

(define is-premise1? (lambda (sentence figure) 
  (equal? (first (regexp-split sentence '.)) (first (forms figure)))))

(define is-premise2? (lambda (sentence figure) 
  (equal? (first (regexp-split sentence '.)) (second (forms figure)))))

(define is-conclusion? (lambda (x) (and (equal? (first (regexp-split x '.)) 'C-A))))

(define premise-1s (lambda (figure)
  (filter 
    (lambda (sent) (is-premise1? sent figure))
    syllogistic-sentences)))

(define premise-2s (lambda (figure)
  (filter 
    (lambda (sent) (is-premise2? sent figure))
    syllogistic-sentences)))

(define sp 
  (map (lambda (x)
         (let ([lst
                (map (lambda (y) 
                       (map (lambda (z)
                              (list x (list y z)))
                            (premise-2s x)))
                     (premise-1s x))])
           (append (first lst) (second lst) (third lst) (fourth lst))))
       '(1 2 3 4)))

(define all-premises (append (first sp) (second sp) (third sp) (fourth sp)))

;; takes a string like 'A-B.all and returns (list 'A 'B 'all)
(define unpack-sentence (lambda (sentence)
  (let ([sentence-fragments (string-split sentence '.)])
    (flatten (list (string-split (first sentence-fragments) '-) (second sentence-fragments))))))


(define has-property? (lambda (x i ABC) (list-ref (ABC x) (position property-order i))))


; assume the situations constructed have at least one object with each of the properties
; (define existential-import (lambda (A B objects) 
;                              (and (some-true (map A objects)) (some-true (map B objects)))))

(define existential-import-m (lambda (ABC objects term1 term2)
                             (and (some-true (map (lambda (x) (has-property? x term1 ABC)) objects))
                                  (some-true (map (lambda (x) (has-property? x term2 ABC)) objects)))))

; (define plentiful-worlds (lambda (A B C objects)
;         (and (some-true (map A objects)) (some-true (map B objects)) (some-true (map C objects)))))

(define plentiful-worlds-m (lambda (ABC objects)
                             (and (some-true (map (lambda (x) (has-property? x 'A ABC)) objects))
                                  (some-true (map (lambda (x) (has-property? x 'B ABC)) objects))
                                  (some-true (map (lambda (x) (has-property? x 'C ABC)) objects)))))

; (define all (lambda (A B objects)
;               (if (existential-import A B objects)
;                   (all-true (map (lambda (x) (if (A x) (B x) true)) 
;                                  objects))
;                   false)))

; (define some (lambda (A B objects)
;                (if (existential-import A B objects)
;                    (some-true (map (lambda (x) (if (A x) (B x) false)) 
;                                    objects))
;                    false)))

; (define none (lambda (A B objects)
;                (if (existential-import A B objects)
;                    (all-true (map (lambda (x) (if (A x) (not (B x)) true)) 
;                                   objects))
;                    false)))

; (define not-all (lambda (A B objects)
;                   (if (existential-import A B objects)
;                       (some-true (map (lambda (x) (if (A x) (not (B x)) false)) 
;                                       objects))
;                       false)))

(define all-m (lambda (ABC objects property1 property2)
  (if (existential-import-m ABC objects property1 property2)
      (all-true (map 
        (lambda (x) (if (has-property? x property1 ABC) (has-property? x property2 ABC) true))
                     objects))
      false)))

(define some-m (lambda (ABC objects property1 property2)
  (if (existential-import-m ABC objects property1 property2)
      (some-true (map 
        (lambda (x) (if (has-property? x property1 ABC) (has-property? x property2 ABC) false))
                     objects))
      false)))

(define none-m (lambda (ABC objects property1 property2)
  (if (existential-import-m ABC objects property1 property2)
      (all-true (map 
        (lambda (x) (if (has-property? x property1 ABC) (not (has-property? x property2 ABC)) true))
                     objects))
      false)))

(define not-all-m (lambda (ABC objects property1 property2)
  (if (existential-import-m ABC objects property1 property2)
      (some-true (map 
        (lambda (x) (if (has-property? x property1 ABC) (not (has-property? x property2 ABC)) false))
                     objects))
      false)))




; pass strings, which then call functions of the same name

; (define (meaning word)
;   (case word
;         (('all) all)
;         (('some) some)
;         (('not-all) not-all)
;         (('none) none)))

(define (meaning word)
  (case word
        (('all) all-m)
        (('some) some-m)
        (('not-all) not-all-m)
        (('none) none-m)))



; parameter 1: the reasoner's prior beliefs about the rarity of properties
(define br 0.25)

; (define equivalent-transform
;   (mem
;    (lambda (objects)
;      (enumeration-query
;       ; properties map objects to truth-values i.e. whether or not the object has the property
;       ; together with the list of objects, these represent situations over which reasoning occurs
;       (define A (mem (lambda (x) (flip br))))
;       (define B (mem (lambda (x) (flip br))))
;       (define C (mem (lambda (x) (flip br))))
;       (define (property p)
;         (case p
;               (('A) A)
;               (('B) B)
;               (('C) C)))
      
;       (map 
;         (lambda (sentence) 
;           (let ([s (unpack-sentence sentence)]) 
;           ((meaning (third s)) (property (first s)) (property (second s)) objects))) 
;         syllogistic-sentences)


;      ;true
;      (plentiful-worlds A B C objects)))))


(define binom->multinom
  (mem
    (lambda (br)
      (enumeration-query
        (define A (mem (lambda (x) (flip br))))
          (define B (mem (lambda (x) (flip br))))
          (define C (mem (lambda (x) (flip br))))

          (list (A 'x) (B 'x) (C 'x))

          true))))

(define multinomial-properties 
  '((#f #f #f) (#f #f #t) (#f #t #f) (#f #t #t) 
    (#t #f #f) (#t #f #t) (#t #t #f) (#t #t #t)))

(define equivalent-transform-m
  (mem
   (lambda (objects background-prior)
     (enumeration-query
;      (define ABC (mem (lambda (x) (apply multinomial background-prior))))
      (define ABC (mem (lambda (x) (multinomial multinomial-properties background-prior))))
      
      (map 
        (lambda (sentence) 
          (let ([s (unpack-sentence sentence)]) 
          ((meaning (third s)) ABC objects (first s) (second s)))) 
        syllogistic-sentences)


     ;true
     (plentiful-worlds-m ABC objects)))))

(define lightbulb-beta '(0.16239389 0.09753311 0.02406771 0.05193817 
  0.11577700 0.12365418 0.12412901 0.16787938))
(define lightbulb-alpha 3)
(define lightbulb-hyperparams (map (lambda (x) (* lightbulb-alpha x)) lightbulb-beta))
;; posterior median for 

; alpha 3
;
;       111 0.16787938
; 2      110 0.12412901
; 3      101 0.12365418
; 4      011 0.05193817
; 5      100 0.11577700
; 6      010 0.02406771
; 7      001 0.09753311
; 8      000 0.16239389


(define hyper-equivalent-transform-m
  (lambda (hyperpiors)
   (rejection-query

    (define background-prior (dirichlet hyperpiors))

    (equivalent-transform-m objs background-prior)

    true
     )))



; parameter 2: number of objects in the situation the reasoner imagines
(define objs (list 'o1 'o2 'o3))

;(define equivalent-worlds (equivalent-transform-m objs (binom->multinom 0.25)))
(define state-prior-prior 
  (repeat 3 (lambda () (hyper-equivalent-transform-m lightbulb-hyperparams))))


(define state->sentences
  (lambda (situation) 
    (filter 
      (lambda (x) (list-ref situation (position syllogistic-sentences x)))
      syllogistic-sentences)))



(define alpha 3)

(define (marginalize interpretation)
  (list
    (list 'C-A.all 'C-A.some 'C-A.none 'C-A.not-all)
    (list
     (sum (map (lambda (y) (second y)) (filter (lambda (x) (first (first x)))
                                               (zip (first interpretation) (second interpretation)))))
     (sum (map (lambda (y) (second y)) (filter (lambda (x) (second (first x)))
                                               (zip (first interpretation) (second interpretation)))))
     (sum (map (lambda (y) (second y)) (filter (lambda (x) (third (first x)))
                                               (zip (first interpretation) (second interpretation)))))
     (sum (map (lambda (y) (second y)) (filter (lambda (x) (fourth (first x)))
                                               (zip (first interpretation) (second interpretation))))))))

(define reasoner1
  (mem (lambda  (premises figure)
    (enumeration-query
       (define equivalent-worlds (uniform-draw state-prior-prior))
       (define state (apply multinomial equivalent-worlds))
       (define true-conclusions (filter is-conclusion? (state->sentences state)))
       (define conclusion (uniform-draw true-conclusions))
       (define which-conclusions (list 
            (is-element? 'C-A.all true-conclusions)
            (is-element? 'C-A.some true-conclusions)
            (is-element? 'C-A.none true-conclusions)
            (is-element? 'C-A.not-all true-conclusions)))

       conclusion
       ;true-conclusions
       ;which-conclusions

       (equal? premises (apply multinomial (experimenter1 conclusion figure equivalent-worlds)))
       ;(equal? premises (apply multinomial (experimenter1 conclusion figure)))
       ;(equal? premises (apply multinomial (experimenter1 true-conclusions figure)))
       ;(equal? premises (apply multinomial (experimenter1 which-conclusions figure)))
       ))))

(define experimenter1
  (mem (lambda (QUDval figure equivalent-worlds)
;  (mem (lambda (QUDval figure)   
     (enumeration-query
      (define premises (list (uniform-draw (premise-1s figure)) (uniform-draw (premise-2s figure))))
      
      premises
      
      (equal? 
        QUDval 
        ;(apply multinomial (raise-to-power (marginalize (reasoner0 premises)) alpha)))))))
        (apply multinomial (raise-to-power (reasoner0 premises equivalent-worlds) alpha)))))))

(define reasoner0
   (mem 
    (lambda  (premises equivalent-worlds)
;    (lambda  (premises)
      (enumeration-query
;       (define equivalent-worlds (uniform-draw state-prior-prior))
       (define state (apply multinomial equivalent-worlds))
       (define true-sentences (state->sentences state))
       (define conclusion (uniform-draw (filter is-conclusion? true-sentences)))
       (define which-conclusions (list 
            (is-element? 'C-A.all true-sentences)
            (is-element? 'C-A.some true-sentences)
            (is-element? 'C-A.none true-sentences)
            (is-element? 'C-A.not-all true-sentences)))

       conclusion
;       (filter is-conclusion? true-sentences)
;        which-conclusions

       (and 
          (is-element? (first premises) true-sentences)
          (is-element? (second premises) true-sentences))))))


(define results (map (lambda (x) (list x (reasoner1 (second x) (first x)))) all-premises))

(write-csv results 'syllmodel_lightbulb_hyperprior3_n3_alpha3.csv)

;(reasoner0 (list 'B-A.all 'C-B.all))
;(experimenter1 'C-A.all 1)
;(reasoner1 (list 'B-A.all 'C-B.all) 1)
;(hyper-equivalent-transform-m objs)
