// time webppl syllogism-test.wppl --require syllUtils

// var fpath = "/Users/mht/Documents/research/syllogism/models/ripsdata/"
// var ripsData = syllUtils.readCSV(fpath+"rips-data-raw.csv").data
// var ripsDF = dataFrame(ripsData)
// var syllogisms = _.uniq(_.pluck(ripsDF, "syllogism"))

// for testing purposes, keep n_objects fixed
var n_objects = 4
var objects = ["g1","g2","g3", "g4"]

var RSAoptions ={pragmaticInterpretation: false,
                 QUD_E1: "conclusion", // if pragmaticInterpretation==false, this must be conclusion
                 pragmaticProduction: true,
                 QUD_cL0: "state"}



var RSAparams = {
 speakerOptimality_E1: 3,
 speakerOptimality_cL0: 2,
 cost: 1
}


// var priorfilepath = "/Users/mht/Documents/research/syllogism/data/03syllogism_prior_psychjs/";
// var priordata = syllUtils.readCSV(priorfilepath + "prior-exp-mturk_collapsed_means_n71.csv").data
// var priorDF = _.object(map(function(obj){return [obj["domain"], obj] }, dataFrame(priordata)))

// var empiricalPrior = extractMultinomial(priorDF["lightbulbs"])

// var empiricalPrior = [1,1,1,1,1,1,1,1]

var priorParams = {
	 baseRate: 0.4,
	 // baseRate: null,
	 objects: objects,
	 // empiricalPrior: empiricalPrior
	 empiricalPrior: [null]
}

var syllogism = 'IA1'

// var data = _.pluck(subset(ripsDF, "syllogism", syllogism), "conclusion")
var syll = scholasticCodeToPremises(syllogism)

// syllogisticRSA(syll, [["C","A"],"all"], RSAparams, RSAoptions)




var predictionERP = syllogisticRSA(syll, 
					 RSAparams, 
					 RSAoptions,
					 priorParams)
predictionERP


var marginalizeConclusions = function(reasonerERP, conclusion){
Enumerate(function(){
  var c = sample(reasonerERP)
  return _.isArray(c[1]) ? 
  	conclusion[1]==c[0][1] || conclusion[1]==c[1][1] : 
  	conclusion[1]==c[1]
})
}

console.log("P(all) =" + Math.exp(marginalizeConclusions(predictionERP,[["C","A"], "all"]).score([], true)))
console.log("P(some) =" + Math.exp(marginalizeConclusions(predictionERP,[["C","A"], "some"]).score([], true)))
console.log("P(not all) = " + Math.exp(marginalizeConclusions(predictionERP,[["C","A"], "not all"]).score([], true)))
console.log("P(none) =" + Math.exp(marginalizeConclusions(predictionERP,[["C","A"], "none"]).score([], true)))

// var phi = 0

// var linkedERP = addGuessing(predictionERP, phi)
// linkedERP
// var scr = sum(map(function(d){
// 	return predictionERP.score([], d)
// }, data))

// priorDF
