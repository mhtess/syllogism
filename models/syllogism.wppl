// time ~/tools/webppl-github/webppl syllogism.wppl

var hasProperty = function(props, term){
	return props[["A","B","C"].indexOf(term)]
  // return props[term]
}

var allOverObjectVals = function(fn, obj){
	return all( function(kv){return fn(kv)}, obj)
}

var anyOverObjectVals = function(fn, obj){
	return any( function(kv){return fn(kv)}, obj)
}

var someSentence = function(obj, terms){
  var conditionalProperty = function(val){
    return hasProperty(val, terms[0]) ? hasProperty(val, terms[1]) : 0
  }
  return anyOverObjectVals(conditionalProperty, obj)
}


var allSentence = function(obj, terms){
  var conditionalProperty = function(val){
    return hasProperty(val, terms[0]) ? hasProperty(val, terms[1]) : 1
  }
  return allOverObjectVals(conditionalProperty, obj) //&& someSentence(obj, terms) // ALL --> SOME
}

var meaning = function(quantifier) {
   quantifier == "all" ? allSentence  :
   quantifier == "some" ? someSentence :
   quantifier == "none" ? function(obj, terms){  1 - someSentence(obj, terms) } :
   quantifier == "not all"? function(obj, terms){ 1 - allSentence(obj, terms) } :
   true
}

var quantifiers = ["all","some","none", "not all"];
var sentenceForms = [
  ["A","B"],
  ["B","A"],
  ["B","C"],
  ["C","B"],
  ["A","C"],
  ["C","A"]
];


var quantifierSentences = _.flatten(map(
	function(x){
		return map(
			function(y){
				return { quantifier: x, //terms: y,
          terms: y[0] + y[1] }
			} ,sentenceForms)
	}, quantifiers)
)

// var sentencesByPremise = {
//   "AB": _.filter(quantifierSentences, {terms: ["A", "B"]}),
//   "BC": _.filter(quantifierSentences, {terms: ["B", "C"]}),
//   "BA": _.filter(quantifierSentences, {terms: ["B", "A"]}),
//   "CB": _.filter(quantifierSentences, {terms: ["C", "B"]})
// }

var sentencesByPremise = {
  "AB": _.filter(quantifierSentences, {terms: "AB"}),
  "BA": _.filter(quantifierSentences, {terms: "BA"}),
  "BC": _.filter(quantifierSentences, {terms: "BC"}),
  "CB": _.filter(quantifierSentences, {terms: "CB"})
}


var repeatFlip = function(br){
  return Infer({model: function(){
    repeat(3, function(){flip(br) ? 1 : 0})
  }})
}

var base_rate = 0.25
var PropertyDist = repeatFlip(base_rate)

// var probs = [0.125,0.125,0.5,0.125,0.01,0.3,0.1,0.125]
var n = 5

var property_values = PropertyDist.support()
var probs = map(function(s){return Math.exp(PropertyDist.score(s))}, property_values)
// var probs = repeat(8, function(){ 1 })

var MultinomialObjectDistribution = Infer({model: function(){
	var objects = multinomial(normalize(probs), n)
	var objects_w_values = _.zip(objects, property_values)
  var situation = map(second, filter(first, objects_w_values))
  condition(sum(map(first, situation)) > 0)
  condition(sum(map(second, situation)) > 0)
  condition(sum(map(third, situation)) > 0)

	// condition(situation.length > 2) // minimum 3 objects
	// map(function(s){
	// 	condition(sum(s) > 0) // no empty object
	// }, situation)

	return situation
}, method: "enumerate"})

// var PoissonObjectDistribution = Categorical({
// 	vs: UniqueObjectDistribution.support(),
// 	ps: map(function(s){
// 		Math.exp(Poisson({mu: 1}).score(s.length-1))
// 	}, UniqueObjectDistribution.support())
// })

// cost to having more properties (i.e., properties are rare)
var PoissonObjectDistribution = Categorical({
	vs: MultinomialObjectDistribution.support(),
	ps: map(function(s){
		Math.exp(
			Poisson({mu: 1}).score(s.length-1) + sum(map(function(si){
				Poisson({mu: 1}).score(sum(si))
				// sum(map(function(sii){
				// 	return Binomial({p:0.25, n: 1}).score(sii)
				// }, si))
			}, s))
		)
	}, MultinomialObjectDistribution.support())
})

var possiblePriors = {
	binomial: MultinomialObjectDistribution,
	poisson: PoissonObjectDistribution
}

var EquivalenceDistribution = cache(function(priorName){
	Infer({model: function(){
	  var situation = sample(possiblePriors[priorName])
		return map(function(sentence){
			return extend(sentence, {
				truthValue: meaning(sentence.quantifier)(situation, sentence.terms)
			})
		}, quantifierSentences)
	}, method: "enumerate"})
})


var qudFns = {
  state: function(state) { return state },
  conclusion: function(state) {
    var trueConclusions = _.filter(state,
        {truthValue: 1, terms: conclusionForm}
    )
    return uniformDraw(trueConclusions).quantifier
    // return trueConclusions
  }
}

// var conclusionForm =  ["C", "A"]
var conclusionForm =  "CA"

var literalListener = cache(function(premises, qud, priorName) {
  Infer({model: function(){
    var state = sample(EquivalenceDistribution(priorName))

		if (premises != "silence"){
			var state1 = _.find(state, premises[0])
	    var state2 = _.find(state, premises[1])

	    condition(state1.truthValue && state2.truthValue)
		}

    var trueConclusions = _.filter(state,
        {terms: conclusionForm, truthValue: 1}
    )

		var conclusion = uniformDraw(trueConclusions).quantifier
    var qudVal = qud == "state" ? state : conclusion

    return qudVal

  }, method: "enumerate"})
}, 10000)

// var alpha = 5;
var speaker = cache(function(qudVal, qud, premsSpoken, priorName, alpha){
  Infer({model: function(){
    var premises = [
      uniformDraw(sentencesByPremise[premsSpoken[0]["terms"]]),
      uniformDraw(sentencesByPremise[premsSpoken[1]["terms"]])
    ]
		// var premises = flip() ? premsSpoken : "silence"

    var L0 = literalListener(premises, qud, priorName)
    factor(alpha * L0.score(qudVal))
    // factor(1 * L0.score(qudVal))
    return premises

  }, method: "enumerate"})
}, 10000)

var pragmaticListener = function(premises, qud, priorName, alpha){
  Infer({model: function(){
    var state = sample(EquivalenceDistribution(priorName))
    // var qudFn = qudFns[qud]
    // var qudVal = qudFn(state)
    var trueConclusions = _.filter(state,
        {terms: conclusionForm, truthValue: 1}
    )
    // var qudVal = uniformDraw(_.filter(state,
        // {terms: conclusionForm}
    // )).quantifier
    // condition(conclusion.truthValue == 1)
    // var qudVal = conclusion.quantifier
		var conclusion = uniformDraw(trueConclusions).quantifier
    var qudVal = qud == "state" ? state : conclusion

    // var qudVal = uniformDraw(["all", "some", "not all", "none"])
    var S1 = speaker(qudVal, qud, premises, priorName, alpha)

    // var state1 = _.find(state, premises[0])
    // var state2 = _.find(state, premises[1])
    // condition(state1.truthValue && state2.truthValue)

    // display(JSON.stringify(qudVal) + " " + S1.score(premises))
    observe(S1, premises)
    // factor(alpha * S1.score(premises))
    // display(qudVal + " " + S1.score(premises))
    // var sp = sample(S1)

    // return [qudVal, S1.score(premises)] //score(premises)
    // var conclusionQUD = qudFns["conclusion"]
    // return conclusionQUD(state)
    // return uniformDraw(qudVal).quantifier
    return conclusion
  }, method: "enumerate"})
}

var quantifierDictionary = {
	"A": "all", "E": "none", "I": "some", "O": "not all"
}

var figureDictionary = {
	1: {p1: "AB", p2: "BC"},
	2: {p1: "BA", p2: "CB"},
	3: {p1: "AB", p2: "CB"},
	4: {p1: "BA", p2: "BC"}
}


_.flatten(map(function(opts){

	var syllogism = [
	  { quantifier: quantifierDictionary[opts.p1], terms: figureDictionary[opts.figure]["p1"] },
	  { quantifier: quantifierDictionary[opts.p2], terms: figureDictionary[opts.figure]["p2"] }
	]

	var priorPredictions = literalListener("silence", "conclusion", opts.priorName)
	var L0pred = literalListener(syllogism, "conclusion", opts.priorName)
	var L1pred_cnclQud = pragmaticListener(syllogism, "conclusion", opts.priorName, opts.alpha)
	var L1pred_stateQud = pragmaticListener(syllogism, "state", opts.priorName, opts.alpha)

	map(function(q){
		return {
			syllogism: opts.p1 + opts.p2 + opts.figure,
			conclusion: q,
			priorName: opts.priorName,
			speakerOptimality: opts.alpha,
			prior: Math.exp(priorPredictions.score(q)),
			L0: Math.exp(L0pred.score(q)),
			L1_state: Math.exp(L1pred_stateQud.score(q)),
			L1_cncl: Math.exp(L1pred_cnclQud.score(q))
		}
	}, quantifiers)

}, simulationParams))



// display(JSON.stringify()
// speaker("none", "conclusion")
// pragmaticListener(syllogism, "conclusion")

// EquivalenceDistribution.support().length
// .score(
//   [
//     { quantifier: 'all', terms: 'BA' },
//     { quantifier: 'all', terms: 'CB' }
//   ]
// )


// literalListener(syllogism, "state")

// _.filter(sample(EquivalenceDistribution),
// {terms: conclusionForm}
// )
// binomialProbabilities(0.25)
// quantifierSentences
