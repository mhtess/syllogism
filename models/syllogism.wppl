// time webppl syllogism.wppl --require syllUtils

var fpath = "/Users/mht/Documents/research/syllogism/models/ripsdata/"


// prior data for models with content effects

var priorfilepath = "/Users/mht/Documents/research/syllogism/data/03syllogism_prior_psychjs/";
var priordata = syllUtils.readCSV(priorfilepath + "prior-exp-mturk_collapsed_means_n71.csv").data
var priorDF = _.object(map(function(obj){return [obj["domain"], obj] }, dataFrame(priordata)))


// reasoning data foor models with content effects
var datafilepath = "/Users/mht/Documents/research/syllogism/data/";
var drfile1 = datafilepath + "03syllogism_reasoning/syllbelief-exp-mturk_all_n250.csv";
var drfile2 = datafilepath + "04syllogism_reasoning/syllbelief-exp2-mturk.csv";
var exp1data = syllUtils.readCSV(drfile1).data
var exp2data = syllUtils.readCSV(drfile2).data
var dataDF = subset(_.flatten([dataFrame(exp1data), dataFrame(exp2data)]), "condition", "radio")

var syllogisms = _.uniq(_.pluck(dataDF, "syll"))
var domains = _.uniq(_.pluck(dataDF, "domain"))

// Rips (1994) data
// var ripsData = syllUtils.readCSV(fpath+"evans-data-raw-boolean.csv").data
// var ripsDF = dataFrame(ripsData)
// var syllogisms = _.uniq(_.pluck(ripsDF, "syllogism"))

 // for testing purposes, keep n_objects fixed
var n_objects = 4
var objects = ["g1","g2","g3", "g4"]

var RSAoptions ={pragmaticInterpretation: false,
                 QUD_E1: "conclusion", // if pragmaticInterpretation==false, this must be conclusion
                 pragmaticProduction: true,
                 QUD_cL0: "premises"}

var pre1 = RSAoptions["pragmaticInterpretation"] ? 
				"pragInt-" + 'qudE1' + RSAoptions["QUD_E1"] + "_" : ""
var pre2 = RSAoptions["pragmaticProduction"] ? 
				"pragProd-" + 'qudcL0' + RSAoptions["QUD_cL0"] +"_": ""

var optPrefix = pre1 + pre2
				
console.log("running " + optPrefix)

var booleanDictionary = {
	"TRUE":true,
	"FALSE":false
}

var booleanDictionary2 = {
	"1":true,
	"0":false
}

var dataDictionary = {
	"all":"radio_A",
	"some":"radio_I",
	"not all":"radio_O",
	"none":"radio_E"
}



var conclusions = ["all", "some", "not all", "none"]
// var conclusion = conclusions[0]
// var domain = domains[0]


// priorDF
// console.log(domains)

// map(function(d){return extractMultinomial(priorDF[d])}, domains)

// domains

// priorDF
// prior
// syllogismData

// domains

//
// syllogismData

var modelAnalysis = function(){
	// var t0 = syllUtils.getTime()

	var phi= uniform(0,1)

	var RSAparams = {
	 speakerOptimality_E1: RSAoptions["pragmaticInterpretation"] ? uniform(0,20) : 0,
	 speakerOptimality_cL0: RSAoptions["pragmaticProduction"] ? uniform(0,20) : 0,
	 cost: uniform(0,5)
	}

	// var priorParams = {
	// 	baseRate: uniform(0,1),
	// 	objects: objects,
	// 	empiricalPrior: [null]
	// }

	foreach(domains, function(domain){

		var empiricalPrior = extractMultinomial(priorDF[domain])
		var domainData = subset(dataDF, "domain", domain)

		var priorParams = {
			baseRate: null,
			objects: objects,
			empiricalPrior: empiricalPrior
		}

		foreach(syllogisms, function(syllogism){


			var syllogismData = subset(domainData, "syll", syllogism)

			// var data = _.pluck(subset(ripsDF, "syllogism", syllogism), "conclusion")
			// var syllogismData = subset(ripsDF, "syllogism", syllogism)
			// var conclusions = _.uniq(_.pluck(syllogismData, "conclusion"))

			var syll = scholasticCodeToPremises(syllogism)

			foreach(conclusions, function(conclusion){
				// var responseData = _.pluck(subset(syllogismData, 
				// 									"conclusion", 
				// 									conclusion), 
				// 						"response")
				var responseData = _.pluck(syllogismData, dataDictionary[conclusion])

				var predictionERP = syllogisticRSA(syll, 
													[["C","A"], conclusion],
													 RSAparams, 
													 RSAoptions,
													 priorParams)


				var linkedERP = addGuessing(predictionERP, phi)

				var scr = sum(map(function(d){
					return linkedERP.score([], booleanDictionary2[d])
				}, responseData))
				// console.log(scr)
				factor(scr)

				// query.add(["predictive","NA", syllogism,conclusion], 
				// 			Math.exp(linkedERP.score([], true)))

				query.add(["predictive",domain, syllogism,conclusion], 
							Math.exp(linkedERP.score([], true)))


			})
			// foreach(["all","some","not all","none"],
			// 	function(c){
			// 		query.add(["predictive",syllogism,c], Math.exp(linkedERP.score([], c)))
			// })
		})
	})

	RSAoptions["pragmaticProduction"]  ? 
		query.add(["parameter","NA","speakerOptimality_cL0","global"], RSAparams["speakerOptimality_cL0"]) : null
	RSAoptions["pragmaticInterpretation"]  ?
		query.add(["parameter","NA","speakerOptimality_E1","global"], RSAparams["speakerOptimality_E1"]) : null
	RSAparams["baseRate"] != null ? 
		query.add(["parameter","NA","baseRate","global"], RSAparams["baseRate"]) : null

	query.add(["parameter","NA","phi","global"], phi)
	query.add(["parameter","NA","cost","global"], RSAparams["cost"])
	// var t1 = syllUtils.getTime()
	// console.log(t1-t0)
	return query

}

var inference ='IncrMH'
var samples = 150
var burn = 75
// var resultsERP = MCMC(modelAnalysis, {samples:samples, burn:burn, verbose:true})
var resultsERP = IncrementalMH(modelAnalysis, samples, {burn:burn, verbose:true})

console.log('inference complete... printing')

// var outfile = "results/evansData-byConclusion-"+optPrefix+"nObj" + n_objects + "-phi-cost"+ 
// 											inference + samples + "burn" + burn + ".csv"
var outfile = "results/contentExpts-byConclusion-"+optPrefix+"nObj" + n_objects + "-phi-cost"+ 
											inference + samples + "burn" + burn + ".csv"
syllUtils.erpWriter(resultsERP, outfile)

console.log('output written to ' + outfile)
