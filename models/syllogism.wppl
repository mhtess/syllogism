// time webppl syllogism.wppl --require syllUtils

var fpath = "/Users/mht/Documents/research/syllogism/models/ripsdata/"

// Evans (1999) data
var evansData = syllUtils.readCSV(fpath+"evans-data-raw-boolean-fig1.csv").data
var evansDF = dataFrame(evansData)
var syllogisms = _.uniq(_.pluck(evansDF, "syllogism"))

 // for testing purposes, keep n_objects fixed
var n_objects = 4
var objects = ["g1","g2","g3", "g4"]

var RSAoptions ={pragmaticInterpretation: true,
                 QUD_E1: "conclusion", // if pragmaticInterpretation==false, this must be conclusion
                 pragmaticProduction: true,
                 QUD_cL0: "premises"}

var pre1 = RSAoptions["pragmaticInterpretation"] ? 
				"pragInt-" + 'qudE1' + RSAoptions["QUD_E1"] + "_" : ""
var pre2 = RSAoptions["pragmaticProduction"] ? 
				"pragProd-" + 'qudcL0' + RSAoptions["QUD_cL0"] +"_": ""

var optPrefix = pre1 + pre2
				
console.log("running " + optPrefix)

var booleanDictionary = {
	"TRUE":true,
	"FALSE":false
}

var conclusions = ["all", "some", "not all", "none"]


var marginalizeConclusions = function(reasonerERP, conclusion){
	Enumerate(function(){
	  var c = sample(reasonerERP)
	  return _.isArray(c[1]) ? 
	  	(conclusion==c[0][1] || conclusion==c[1][1]) : 
	  	conclusion==c[1]
	})
}

var modelAnalysis = function(){

	var t0 = syllUtils.getTime()

	var phi= uniform(0,1)

	var RSAparams = {
	 speakerOptimality_E1: RSAoptions["pragmaticInterpretation"] ? uniform(0,20) : 0,
	 speakerOptimality_cL0: RSAoptions["pragmaticProduction"] ? uniform(0,20) : 0,
	 cost: 0//uniform(0,5)
	}

	var priorParams = {
		baseRate: uniform(0,1),
		objects: objects,
		empiricalPrior: [null]
	}


	foreach(syllogisms, function(syllogism){

		var data = _.pluck(subset(evansDF, "syllogism", syllogism), "conclusion")
		var syllogismData = subset(evansDF, "syllogism", syllogism)
		var conclusions = _.uniq(_.pluck(syllogismData, "conclusion"))

		var syll = scholasticCodeToPremises(syllogism)

		var predictionERP = syllogisticRSA(syll, 
											 RSAparams, 
											 RSAoptions,
											 priorParams)

		foreach(conclusions, function(conclusion){
			var responseData = _.pluck(subset(syllogismData, 
												"conclusion", 
												conclusion), 
									"response")

			var marginalERP = marginalizeConclusions(predictionERP,
														conclusion)

			var linkedERP = addGuessing(marginalERP, phi)

			var scr = sum(map(function(d){
				return linkedERP.score([], booleanDictionary[d])
			}, responseData))
			// console.log(scr)
			factor(scr)

			query.add(["predictive","NA", syllogism,conclusion], 
						Math.exp(linkedERP.score([], true)))

		})
			// foreach(["all","some","not all","none"],
			// 	function(c){
			// 		query.add(["predictive",syllogism,c], Math.exp(linkedERP.score([], c)))
			// })
	})

	RSAoptions["pragmaticProduction"]  ? 
		query.add(["parameter","NA","speakerOptimality_cL0","global"], RSAparams["speakerOptimality_cL0"]) : null
	RSAoptions["pragmaticInterpretation"]  ?
		query.add(["parameter","NA","speakerOptimality_E1","global"], RSAparams["speakerOptimality_E1"]) : null
	RSAparams["baseRate"] != null ? 
		query.add(["parameter","NA","baseRate","global"], RSAparams["baseRate"]) : null

	query.add(["parameter","NA","phi","global"], phi)
	// query.add(["parameter","NA","cost","global"], RSAparams["cost"])
	var t1 = syllUtils.getTime()
	console.log((t1-t0)/1000)
	return query

}

// console.log(syllogisms)

var inference ='MH'
var samples = 100
var burn = 0
var resultsERP = MCMC(modelAnalysis, {samples:samples, burn:burn, verbose:true})
// resultsERP
console.log('inference complete... printing')

var outfile = "results/evansData-conclusionPairs-"+optPrefix+"nObj" + n_objects + "-phi"+ 
											inference + samples + "burn" + burn + ".csv"

syllUtils.erpWriter(resultsERP, outfile)

console.log('output written to ' + outfile)
