var hasProperty = function(props, term){
	return props[["A","B","C"].indexOf(term)]
  // return props[term]
}

var allOverObjectVals = function(fn, obj){
	return all( function(kv){return fn(kv)}, obj)
}

var anyOverObjectVals = function(fn, obj){
	return any( function(kv){return fn(kv)}, obj)
}

var someSentence = function(obj, terms){
  var conditionalProperty = function(val){
    return hasProperty(val, terms[0]) ? hasProperty(val, terms[1]) : 0
  }
  return anyOverObjectVals(conditionalProperty, obj)
}


var allSentence = function(obj, terms){
  var conditionalProperty = function(val){
    return hasProperty(val, terms[0]) ? hasProperty(val, terms[1]) : 1
  }
  return allOverObjectVals(conditionalProperty, obj) //&& someSentence(obj, terms) // ALL --> SOME
}

var meaning = function(quantifier) {
   quantifier == "all" ? allSentence  :
   quantifier == "some" ? someSentence :
   quantifier == "none" ? function(obj, terms){  1 - someSentence(obj, terms) } :
   quantifier == "not all"? function(obj, terms){ 1 - allSentence(obj, terms) } :
   true
}

var quantifiers = ["all","some","none", "not all"];
var sentenceForms = [
  ["A","B"],
  // ["B","A"],
  ["B","C"],
  // ["C","B"],
  ["A","C"]//,
  // ["C","A"]
];


var quantifierSentences = _.flatten(map(
	function(x){
		return map(
			function(y){
				return { quantifier: x, terms: y}
			} ,sentenceForms)
	}, quantifiers)
)

var sentencesByPremise = {
  "AB": _.filter(quantifierSentences, {terms: ["A", "B"]}),
  "BC": _.filter(quantifierSentences, {terms: ["B", "C"]})
}

var repeatFlip = function(br){
  return Infer({model: function(){
    repeat(3, function(){flip(br) ? 1 : 0})
  }})
}

var base_rate = 0.25
var PropertyDist = repeatFlip(base_rate)

// var probs = [0.125,0.125,0.5,0.125,0.01,0.3,0.1,0.125]
var n = 5

var property_values = PropertyDist.support()
var probs = map(function(s){return Math.exp(PropertyDist.score(s))}, property_values)

var EquivalenceDistribution = Infer({model: function(){
	var objects = multinomial(normalize(probs), n)
	var objects_w_values = _.zip(objects, property_values)
  var situation = map(second, filter(first, objects_w_values))

  // force nonempty sets
  condition(sum(map(first, situation)) > 0)
  condition(sum(map(second, situation)) > 0)
  condition(sum(map(third, situation)) > 0)

	return map(function(sentence){
		return extend(sentence, {truthValue: meaning(sentence.quantifier)(situation, sentence.terms)})
	}, quantifierSentences)
  // return situation
}, method: "enumerate"})

// EquivalenceDistribution
///

var qudFns = {
  state: function(state) { return state },
  conclusion: function(state) {
    var trueConclusions = _.filter(state,
        {truthValue: 1, terms: conclusionForm}
    )
    return uniformDraw(trueConclusions).quantifier
    // return trueConclusions
  }
}

var conclusionForm =  ["A", "C"]

var literalListener = function(premises, qud) {
  Infer({model: function(){
    var state = sample(EquivalenceDistribution)

    var state1 = _.find(state, premises[0])
    var state2 = _.find(state, premises[1])

    condition(state1.truthValue && state2.truthValue)

    var qudFn = qudFns[qud]
    var qudVal = qudFn(state)
    return qudVal

  }, method: "enumerate"})
}

var alpha = 10;
var speaker = function(qudVal, qud){
  Infer({model: function(){
    var premises = [
      uniformDraw(sentencesByPremise.AB),
      uniformDraw(sentencesByPremise.BC)
    ]

    var L0 = literalListener(premises, qud)
    factor(alpha * L0.score(qudVal))
    // factor(1 * L0.score(qudVal))
    return premises

  }, method: "enumerate"})
}

var pragmaticListener = function(premises, qud){
  Infer({model: function(){
    var state = sample(EquivalenceDistribution)
    var qudFn = qudFns[qud]
    var qudVal = qudFn(state)

    var S1 = speaker(qudVal, qud)

    // var state1 = _.find(state, premises[0])
    // var state2 = _.find(state, premises[1])
    // condition(state1.truthValue && state2.truthValue)

    // display(JSON.stringify(qudVal) + " " + S1.score(premises))
    observe(S1, premises)
    // factor(alpha * S1.score(premises))

    // var sp = sample(S1)

    // return [qudVal, S1.score(premises)] //score(premises)
    // var conclusionQUD = qudFns["conclusion"]
    // return conclusionQUD(state)
    // return uniformDraw(qudVal).quantifier
    return qudVal
  }, method: "enumerate"})
}

pragmaticListener([
  { quantifier: 'all', terms: [ 'A', 'B' ]},
  { quantifier: 'all', terms: [ 'B', 'C' ]}
], "conclusion")

// speaker("all", "conclusion")
// binomialProbabilities(0.25)
// quantifierSentences
