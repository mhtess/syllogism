// time webppl syllogism.wppl --require syllUtils

var fpath = "/Users/mht/Documents/research/syllogism/models/ripsdata/"
var ripsData = syllUtils.readCSV(fpath+"rips-data-raw-boolean.csv").data
var ripsDF = dataFrame(ripsData)
var syllogisms = _.uniq(_.pluck(ripsDF, "syllogism"))

// for testing purposes, keep n_objects fixed
var n_objects = 4
var objects = ["g1","g2","g3", "g4"]

var RSAoptions ={pragmaticInterpretation: true,
                 QUD_E1: "conclusion", // if pragmaticInterpretation==false, this must be conclusion
                 pragmaticProduction: false,
                 QUD_cL0: "premises"}

var booleanDictionary = {
	"TRUE":true,
	"FALSE":false
}

var modelAnalysis = function(){

	var phi= uniform(0,1)

	var RSAparams = {
	 speakerOptimality_E1: RSAoptions["pragmaticInterpretation"] ? uniform(0,20) : 0,
	 speakerOptimality_cL0: RSAoptions["pragmaticProduction"] ? uniform(0,20) : 0,
	 baseRate: uniform(0,1),
	 objects: objects,
	 cost: uniform(0,2)
	}

	foreach(syllogisms, function(syllogism){
		// var data = _.pluck(subset(ripsDF, "syllogism", syllogism), "conclusion")
		var syllogismData = subset(ripsDF, "syllogism", syllogism)
		var conclusions = _.uniq(_.pluck(syllogismData, "conclusion"))
		var syll = scholasticCodeToPremises(syllogism)

		foreach(conclusions, function(conclusion){
			var responseData = _.pluck(subset(syllogismData, 
												"conclusion", 
												conclusion), 
									"response")

			var t0 = syllUtils.getTime()
			var predictionERP = syllogisticRSA(syll, 
												[["C","A"], conclusion],
												 RSAparams, 
												 RSAoptions)
			var t1 = syllUtils.getTime()
			console.log(t1-t0)

			var linkedERP = addGuessing(predictionERP, phi)

			var scr = sum(map(function(d){
				return linkedERP.score([], booleanDictionary[d])
			}, responseData))
			// console.log(scr)
			factor(scr)

			query.add(["predictive",syllogism,conclusion], 
						Math.exp(linkedERP.score([], true)))


		})
		// foreach(["all","some","not all","none"],
		// 	function(c){
		// 		query.add(["predictive",syllogism,c], Math.exp(linkedERP.score([], c)))
		// })
	})

	RSAoptions["pragmaticProduction"]  ? 
		query.add(["parameter","speakerOptimality_cL0","global"], RSAparams["speakerOptimality_cL0"]) : null
	RSAoptions["pragmaticInterpretation"]  ?
		query.add(["parameter","speakerOptimality_E1","global"], RSAparams["speakerOptimality_E1"]) : null
	query.add(["parameter","baseRate","global"], RSAparams["baseRate"])
	query.add(["parameter","phi","global"], phi)
	query.add(["parameter","cost","global"], RSAparams["cost"])

	return query

}

var inference ='MH'
var samples = 10
var burn = 0
var resultsERP = MCMC(modelAnalysis, {samples:samples, burn:burn, verbose:true})

console.log('inference complete... printing')
var pre1 = RSAoptions["pragmaticInterpretation"] ? "pragInt-" + 'qudE1' + RSAoptions["QUD_E1"] + "_" : ""
var pre2 = RSAoptions["pragmaticProduction"] ? "pragProd-" + 'qudcL0' + RSAoptions["QUD_cL0"] +"_": ""

var optPrefix = pre1 + pre2
				

var outfile = "results/rips-byConclusion-"+optPrefix+"nObj" + n_objects + "-br-phi-"+ 
											inference + samples + "burn" + burn + ".csv"
syllUtils.erpWriter(resultsERP, outfile)

console.log('output written to ' + outfile)
