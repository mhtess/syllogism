// syllogism.wppl

// webppl syllogism.wppl --require-js ./simpleCSV 


// mht's gensym
globalStore.gensymCounter = 0
var gensym = function(){
  globalStore.gensymCounter = globalStore.gensymCounter+1
  return "g" + globalStore.gensymCounter
}


// load experimental data

// var dfilepath = "/Users/mht/Documents/research/syllogism/analysis/";
// var dfile = dfilepath + "max_posterior_priors" + domain + "_mh1000k.csv";

// var domainPriors = simpleCSV.readCSV(dfile).data;

var n_objects = 4
var objects = repeat(n_objects, gensym)

// creating the syllogistic space

var quantifiers = ["all","some","none", "not all"];
var sentenceForms = [ ["A","B"],["B","A"],
                      ["B","C"],["C","B"],
                      ["A","C"],["C","A"]];

var propertyOrder = ["A","B","C"];

var propertyTuples = [[0,0,0],[0,0,1],[0,1,0],[0,1,1],
                      [1,0,0],[1,0,1],[1,1,0],[1,1,1]]

var conclusionOrder = [ [["C","A"],"all"],
                        [["C","A"],"none"],
                        [["C","A"],"some"],
                        [["C","A"],"not all"]];

var syllogisticSentences = _.flatten(map(function(x)
  {return map(function(y){return [y,x]} ,sentenceForms)}, quantifiers),true)

var premiseForms = {"1":[["B","A"],["C","B"]],
              "2":[["A","B"],["C","B"]],
              "3":[["B","A"],["B","C"]],
              "4":[["A","B"],["B","C"]]}

var scholasticDict = {"all":"A","none":"E","some":"I","not all":"O"}

var isPremise = function(sentence,figure,premiseNo){
  return sentence[0] == premiseForms[figure][premiseNo-1]
}

var syllogisticPremisesNested = map(function(x)
  {return map(function(y)
    {return map(function(q1)
      {return map(function(q2)
        {return [[y,q1],[x,q2]]},
        quantifiers)},
      quantifiers)},
    sentenceForms.slice(0,2))},
  sentenceForms.slice(2,4))

var syllogisticPremises = _.flatten(
  _.flatten(
    _.flatten(syllogisticPremisesNested,
      true),
    true),
  true)

// var stateToSentence = function(state){
//   return filter()
// }

var hasProperty = function(obj, term, properties)
  {return properties(obj)[propertyOrder.indexOf(term)]}

var plentifulWorlds = function(propertiesOfObjects){
  var fOR = function(v1,v2){
    return map2(function(e1,e2){return e1 || e2}, v1, v2)
  }
  return reduce(function(e1,e2){return e1 && e2}, 1, (reduce(fOR,[0,0,0],propertiesOfObjects)))
}

var allSentence = function(properties, objects, termOne, termTwo){
  return sum(map(function(obj)
  {return hasProperty(obj, termOne, properties) ? hasProperty(obj, termTwo, properties): true}, 
   objects)) == n_objects
}

var someSentence = function(properties, objects, termOne, termTwo){
  return sum(map(function(obj)
  {return hasProperty(obj, termOne, properties) ? hasProperty(obj, termTwo, properties): false}, 
   objects)) > 0
}

var notallSentence = function(properties, objects, termOne, termTwo){
  return sum(map(function(obj)
  {return hasProperty(obj, termOne, properties) ? hasProperty(obj, termTwo, properties): false}, 
   objects)) != objects.length
}
var noneSentence = function(properties, objects, termOne, termTwo){
  return sum(map(function(obj)
  {return hasProperty(obj, termOne, properties) ? hasProperty(obj, termTwo, properties): true}, 
   objects)) == 0
}


// equivalence class transformation



var equivalentTransform = function(objects){

  var backgroundPrior = [0.125,0.125,0.125,0.125,0.125,0.125,0.125,0.125]
  var getProperties = cache(function(obj) {
      var p = propertyTuples[discrete(backgroundPrior)]
      return p
    })

  Enumerate(function(){

    var properties = map(getProperties,objects)
    console.log(properties)
    // var meaning = function(quantifier) {
    //   return quantifier=="all"? allSentence :
    //          quantifier=="some"? someSentence :
    //          quantifier=="none"? noneSentence :
    //          quantifier=="not all"? notallSentence : 
    //          true
    // }

   var nonEmptyWorld = plentifulWorlds(properties)
  
   factor(nonEmptyWorld?0:-Infinity)

    return map(function(sentence)
      {return meaning(sentence[1])(properties,
                                    objects,
                                    sentence[0][0],
                                    sentence[0][1])}, 
      syllogisticSentences)
  //  return properties
    //map(properties,objects) + meaning(syllogisticSentences[0][1])(properties,objects,'A','B')

  })
}

equivalentTransform(objects).support().length

//var x = syllogisticSentences[0]
//x[1] + x[0][0] + x[0][1]
//syllogisticSentences.length

//     var backgroundPrior = [1,1,1,1,1,1,1,1]

//     var properties = cache(function(obj) {
//         var p = propertyTuples[discrete(backgroundPrior)]
//         return p
//       })

// var x= map(properties,objects)

// x[0]+ '\n'+ 
// x[1]+ '\n'+
// x[2]+ '\n'+
// x[3]+ '\n'+
// notallSentence(properties,objects,'A','B')

//objects

// var thetaPrior = function() {
//   var threshold = randomInteger(10)
//   return threshold
// }

// var utterancePrior = function() {
//   var utterances = ["generic is true",
//                     "generic is false"]
//  // var utterances = ["generic is true",
//   //                  "mu"]                    
//   var i = randomInteger(utterances.length)
//   return utterances[i]
// }

// var meaning = function(utt,state, theta) {
//   return utt=="generic is true"? state>theta :
//          utt=="generic is false"? state<=theta :
//          true
// }

// var reasoner0 = cache(function(premises, equivalentWorlds) {
//   Enumerate(function(){
//     var state = sample(equivalentWorlds)
//     var trueSentences = stateToSentence(state)
//     var conclusion = sample(filter(isConclusion, trueSentences))

//     var premisesTrue = (indexOf(premises[0], trueSentences)!=undefined &
//     					indexOf(premises[1], trueSentences)!=undefined)

//     factor(premisesTrue?0:-Infinity)
//     return conclusion
//   })
// })

// var experimenter1 = cache(function(QUDval, figure, equivalentWorlds) {
//   Enumerate(function(){
//     var premises = [sample(premise1(figure), sample(premise2(figure))]
//     var R0 = reasoner0(premises, equivalentWorlds)
//     factor(R0.score([],QUDval))
//     return premises
//   })
// })

// var reasoner1 = function(premises, figure) {
//   Enumerate(function(){
//   	var equivalentWorlds = equivalentTransform(objects, properties, ...)
//   	var state = sample(equivalentWorlds)

//     var trueSentences = stateToSentence(state)
//     var conclusion = sample(filter(isConclusion, trueSentences))

//     var E1 = experimenter1(conclusion, figure, equivalentWorlds)
//     factor(E1.score([],utterance))
//     return conclusion
//   })
// }