// syllogism.wppl

// webppl syllogism.wppl --require-js ./simpleCSV 


// mht's gensym
globalStore.gensymCounter = 0
var gensym = function(){
  globalStore.gensymCounter = globalStore.gensymCounter+1
  return "g" + globalStore.gensymCounter
}

var mapObject = function(fn, obj){  
  return _.object(
    map(
      function(kv){
        return [kv[0], fn(kv[0], kv[1])]
      }, 
      _.pairs(obj))
  );
}

var uniformDraw = function(x){
  return x[randomInteger(x.length)]
}


// load prior data

var dfilepath = "/Users/mht/Documents/research/syllogism/data/03syllogism_prior_psychjs/";
var dfile = dfilepath + "prior-exp-mturk_collapsed_means_n71.csv";

var domainPriors = simpleCSV.readCSV(dfile).data;

var propertyTuples = [[0,0,0],[0,0,1],[0,1,0],[0,1,1],
                      [1,0,0],[1,0,1],[1,1,0],[1,1,1]]

var csvPropTup = domainPriors[0].slice(3) // property (tuple) labels e.g. 011

// order csv data to match what's in propertyTuples
var orderPropertyTuples = function(values){
  return map(function(x){
    return simpleCSV.wpParseFloat(values[csvPropTup.indexOf(x.join(""))])
  }, propertyTuples)
}

// create assoc. array out of domainName and ordered probabilities
var priorClean = _.object(map(function(x){
  return [x[1],orderPropertyTuples(x.slice(3))]
},domainPriors.slice(1)))

var domains = ['cracker','knife','strawberry','lightbulb']

///


/// model parameter: number of objects

var n_objects = 3
var objects = repeat(n_objects, gensym)

// creating the syllogistic space

var quantifiers = ["all","some","none", "not all"];
var sentenceForms = [ ["A","B"],["B","A"],
                      ["B","C"],["C","B"],
                      ["A","C"],["C","A"]];

var propertyOrder = ["A","B","C"];


var conclusionOrder = [ [["C","A"],"all"],
                        [["C","A"],"none"],
                        [["C","A"],"some"],
                        [["C","A"],"not all"]];

var syllogisticSentences = _.flatten(map(function(x)
  {return map(function(y){return [y,x]} ,sentenceForms)}, quantifiers),true)

var premiseForms = {"1":[["B","A"],["C","B"]],
                  "2":[["A","B"],["C","B"]],
                  "3":[["B","A"],["B","C"]],
                  "4":[["A","B"],["B","C"]]}

var scholasticDict = {"all":"A","none":"E","some":"I","not all":"O"}

var isPremise = function(sentence,figure,premiseNo){
  return sentence[0] == premiseForms[figure][premiseNo-1]
}

var isConclusion = function(x){
//  return (x[0][0]=='A' || x[0][0]=='C') && (x[0][1]=='A' || x[0][1]=='C')
  return (x[0][0]=='A') && (x[0][1]=='C')
}


var stateToSentence = function(state){
  return filter(function(x){return state[syllogisticSentences.indexOf(x)]
  }, syllogisticSentences)
}

var flattenSentences = function(sentences){
  return map(function(sentence){
    return [sentence[0][0], sentence[0][1], sentence[1]].join()
  },sentences)
}


var syllogisticPremisesNested = map(function(x)
  {return map(function(y)
    {return map(function(q1)
      {return map(function(q2)
        {return [[y,q1],[x,q2]]},
        quantifiers)},
      quantifiers)},
    sentenceForms.slice(0,2))},
  sentenceForms.slice(2,4))

var syllogisticPremises = _.flatten(
  _.flatten(
    _.flatten(syllogisticPremisesNested,
      true),
    true),
  true)


var premiseDictionary = {"1": _.flatten(_.flatten(syllogisticPremisesNested,true)[3],true),
                          "2": _.flatten(_.flatten(syllogisticPremisesNested,true)[2],true),
                          "3": _.flatten(_.flatten(syllogisticPremisesNested,true)[1],true),
                          "4": _.flatten(_.flatten(syllogisticPremisesNested,true)[0],true)}



// quantifier logic and helpers

var hasProperty = function(props,term)
  {return props[propertyOrder.indexOf(term)]}



var plentifulWorlds = function(propObject){
  var pO = map(second,_.pairs(propObject)) // function designed for list of lists
  var fOR = function(v1,v2){
    return map2(function(e1,e2){return e1 || e2}, v1, v2)
  }
  return reduce(function(e1,e2){return e1 && e2}, 1, (reduce(fOR,[0,0,0],pO)))
}

var allOverObjectVals = function(fn, obj)
  {return all(function(kv){return fn(kv[1])}, _.pairs(obj))}

var anyOverObjectVals = function(fn, obj)
  {return any(function(kv){return fn(kv[1])}, _.pairs(obj))}

var allSentence = function(propObject, termOne, termTwo){
  return allOverObjectVals(function(val){return hasProperty(val,termOne)? hasProperty(val,termTwo) : 1},
    propObject)
}

var someSentence = function(propObject, termOne, termTwo){
  return anyOverObjectVals(function(val){return hasProperty(val,termOne)? hasProperty(val,termTwo) : 0},
    propObject)
}

var notallSentence = function(propObject, termOne, termTwo){
  return 1 - allSentence(propObject,termOne,termTwo)
}

var noneSentence = function(propObject, termOne, termTwo){
  return 1 - someSentence(propObject,termOne,termTwo)
}



// equivalence class transformation


var multinomialProbabilities = function(br){
  return [Math.pow(1-br,3),Math.pow(1-br,2)*br,Math.pow(1-br,2)*br,Math.pow(br,2)*(1-br),
          Math.pow(1-br,2)*br,Math.pow(br,2)*(1-br),Math.pow(br,2)*(1-br),Math.pow(br,3)]
}

var equivalentTransform = cache(function(objects, backgroundPrior){

//  var backgroundPrior = [1,1,1,1,1,1,1,1]
//  var backgroundPrior = multinomialProbabilities(0.25)


  var getProperties = function(obj) {
      var p = propertyTuples[discrete(backgroundPrior)]
      return p
    }

  Enumerate(function(){

    var propertiesOfObjects = _.object(_.zip(objects,map(getProperties,objects)))

    var meaning = function(quantifier) {
      return quantifier=="all"? allSentence :
             quantifier=="some"? someSentence :
             quantifier=="none"? noneSentence :
             quantifier=="not all"? notallSentence : 
             true
    }

    var nonEmptyWorld = plentifulWorlds(propertiesOfObjects) 
    factor(nonEmptyWorld?0:-Infinity)

    return map(function(sentence)
      {return meaning(sentence[1])(propertiesOfObjects,
                                    sentence[0][0],
                                    sentence[0][1])}, 
      syllogisticSentences)
  })
})


var flattenSentences = function(sentences){
    return map(function(sentence){
      return [sentence[0][0], sentence[0][1], sentence[1]].join()
    },sentences)
  }

var reasoner0 = cache(function(premises, equivalentWorlds) {
  Enumerate(function(){
    var state = sample(equivalentWorlds)
    var trueSentences = stateToSentence(state)
        // this could probably be optimized
    var flattenedSentences = flattenSentences(trueSentences) 

    var premisesTrue = flattenedSentences.indexOf(premises[0].join())!=-1 &&
                        flattenedSentences.indexOf(premises[1].join())!=-1

    var conclusion = uniformDraw(filter(isConclusion, trueSentences))

    factor(premisesTrue?0:-Infinity)
    return conclusion
  })
})

var experimenter1 = cache(function(QUDval, figure, equivalentWorlds) {
  Enumerate(function(){
    var premises = uniformDraw(premiseDictionary[figure])
    var R0 = reasoner0(premises, equivalentWorlds)
    factor(R0.score([],QUDval))
    return premises
  })
})

var reasoner1 = function(premises, domain, alpha) {
  Enumerate(function(){
    // simple prep stuff
    var figure = _.invert(premiseForms)[premises[0][0]+','+premises[1][0]]
    var backgroundPrior = priorClean[domain]

    // sampling of worlds
    var backoffPrior = [1,1,1,1,1,1,1,1]
    var wonkyworld = flip(0.5)

    var equivalentWorlds = wonkyworld?
                            equivalentTransform(objects, backoffPrior):
                            equivalentTransform(objects,backgroundPrior)

    var state = sample(equivalentWorlds)

    // mapping from worlds to sentences, conclusions
    var trueSentences = stateToSentence(state)
    var conclusion = uniformDraw(filter(isConclusion, trueSentences))

    // recursive reasoning
    var E1 = experimenter1(conclusion, figure, equivalentWorlds)
    factor(alpha*E1.score([],premises))
    return conclusion
  })
}

//var results = map(reasoner1,syllogisticPremises)
//results
var alpha = 2
reasoner1(syllogisticPremises[0], 'cracker', alpha)

//discrete[backgroundPrior]
//var equivalentWorlds = equivalentTransform(objects, backgroundPrior)
//equivalentWorlds

//var results = reasoner1(syllogisticPremises[0])

//var results = reasoner1(syllogisticPremises[0])


//map(function(x){return [x.support(), x.score()]}, results)

// reasoner1([[['A','B'],'all'],
//             [['B','C'],'all']])

//var x = syllogisticSentences[0]
//x[1] + x[0][0] + x[0][1]
//syllogisticSentences.length

//     var backgroundPrior = [1,1,1,1,1,1,1,1]

//     var properties = cache(function(obj) {
//         var p = propertyTuples[discrete(backgroundPrior)]
//         return p
//       })

// var x= map(properties,objects)

// x[0]+ '\n'+ 
// x[1]+ '\n'+
// x[2]+ '\n'+
// x[3]+ '\n'+
// notallSentence(properties,objects,'A','B')

//objects

// var thetaPrior = function() {
//   var threshold = randomInteger(10)
//   return threshold
// }

// var utterancePrior = function() {
//   var utterances = ["generic is true",
//                     "generic is false"]
//  // var utterances = ["generic is true",
//   //                  "mu"]                    
//   var i = randomInteger(utterances.length)
//   return utterances[i]
// }

// var meaning = function(utt,state, theta) {
//   return utt=="generic is true"? state>theta :
//          utt=="generic is false"? state<=theta :
//          true
// }